<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,IE=9,chrome=1"><meta name="generator" content="MATLAB 2024a"><title>QMol_TDSE_SSO_6BM</title><style type="text/css">.rtcContent { padding: 30px; } .S0 { margin: 3px 10px 5px 4px; padding: 0px; line-height: 28.8px; min-height: 0px; white-space: pre-wrap; color: rgb(192, 76, 11); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 24px; font-weight: 400; text-align: left;  }
.S1 { margin: 2px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(33, 33, 33); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S2 { margin: 20px 10px 5px 4px; padding: 0px; line-height: 20px; min-height: 0px; white-space: pre-wrap; color: rgb(33, 33, 33); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 20px; font-weight: 700; text-align: left;  }
.S3 { margin: 10px 0px 20px; padding-left: 0px; font-family: Helvetica, Arial, sans-serif; font-size: 14px;  }
.S4 { margin-left: 56px; line-height: 21px; min-height: 0px; text-align: left; white-space: pre-wrap;  }
.S5 { margin: 15px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(33, 33, 33); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 17px; font-weight: 700; text-align: left;  }
.S6 { margin: 10px 10px 5px 4px; padding: 0px; line-height: 18px; min-height: 0px; white-space: pre-wrap; color: rgb(33, 33, 33); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 15px; font-weight: 700; text-align: left;  }
.CodeBlock { background-color: #F5F5F5; margin: 10px 15px 10px 0; display: inline-block }
.S7 { border-left: 0.555556px solid rgb(217, 217, 217); border-right: 0.555556px solid rgb(217, 217, 217); border-top: 0.555556px solid rgb(217, 217, 217); border-bottom: 0.555556px solid rgb(217, 217, 217); border-radius: 4px; padding: 6px 45px 4px 13px; line-height: 18.004px; min-height: 0px; white-space: nowrap; color: rgb(33, 33, 33); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S8 { margin: 10px 10px 9px 4px; padding: 0px; line-height: 21px; min-height: 0px; white-space: pre-wrap; color: rgb(33, 33, 33); font-family: Helvetica, Arial, sans-serif; font-style: normal; font-size: 14px; font-weight: 400; text-align: left;  }
.S9 { border-left: 0.555556px solid rgb(217, 217, 217); border-right: 0.555556px solid rgb(217, 217, 217); border-top: 0.555556px solid rgb(217, 217, 217); border-bottom: 0px none rgb(33, 33, 33); border-radius: 4px 4px 0px 0px; padding: 6px 45px 0px 13px; line-height: 18.004px; min-height: 0px; white-space: nowrap; color: rgb(33, 33, 33); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }
.S10 { border-left: 0.555556px solid rgb(217, 217, 217); border-right: 0.555556px solid rgb(217, 217, 217); border-top: 0px none rgb(33, 33, 33); border-bottom: 0.555556px solid rgb(217, 217, 217); border-radius: 0px 0px 4px 4px; padding: 0px 45px 4px 13px; line-height: 18.004px; min-height: 0px; white-space: nowrap; color: rgb(33, 33, 33); font-family: Menlo, Monaco, Consolas, "Courier New", monospace; font-size: 14px;  }</style></head><body><div class = rtcContent><h1  class = 'S0' id = 'T_2D7548B9' ><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span></h1><div  class = 'S1'><span>Sixth-order optimized Blanes and Moan [</span><a href = "#M_2A8D1A6C"><span>Blanes 2002</span></a><span>] symplectic split-operator scheme for TDSE simulations.</span></div><h2  class = 'S2' id = 'H_ED346F2A' ><span>Description</span></h2><div  class = 'S1'><span>Use </span><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> to propagate the TDSE dynamics of a </span><a href = "./SE.html"><span>Schrödinger-equation model</span></a><span> with a </span><a href = "./QMol_disc.html"><span>Cartesian-grid discretization domain</span></a><span> using a sixth-order optimized Blanes and Moan [</span><a href = "#M_2A8D1A6C"><span>Blanes 2002</span></a><span>] symplectic split-operator scheme. The time propagation can be performed field free or with an external driving field in the dipole approximation and either length or velocity gauge. The derivation and details of the implementation of the symplectic split-operator can be found in [</span><a href = "#M_F7CBFF54"><span>Mauger 2024</span></a><span>]. During the TDSE propagation, several observables can be computed on-the-fly and stored in output structures in the </span><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> object. Each of these can be activated independently and may define their own sampling times:</span></div><ul  class = 'S3'><li  class = 'S4'><a href = "#H_A211A946"><span>Save the Schrödinger-equation object into individual files</span></a></li><li  class = 'S4'><a href = "#H_A90EE811"><span>Save the dipole, dipole velocity, and dipole acceleration signals</span></a></li><li  class = 'S4'><a href = "#H_FB7F0C94"><span>Save Schrödinger-equation and wave function energies</span></a></li><li  class = 'S4'><a href = "#H_48DDF558"><span>Save the external field information</span></a></li><li  class = 'S4'><a href = "#H_65D2E853"><span>Save the ionization signal</span></a></li><li  class = 'S4'><a href = "#H_E89C839B"><span>Save the wave functions and their projection on a basis</span></a></li><li  class = 'S4'><a href = "#H_236395D1"><span>Save the output of a function of the wave functions</span></a></li><li  class = 'S4'><a href = "#H_5CD2979A"><span>Save restart data file</span></a></li></ul><div  class = 'S1'><span>See the </span><a href = "./TDSE.html"><span>TDSE documentation</span></a><span> page for examples of using most of these features. </span></div><div  class = 'S1'><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> is a handle class overloading </span><span style=' font-family: monospace;'>QMol_TDSE_SSO</span><span> (and thus </span><a href = "./QMol_TDSE_sympSplitOp.html"><span style=' font-family: monospace;'>QMol_TDSE_sympSplitOp</span></a><span> and </span><a href = "./QMol_TDSE.html"><span style=' font-family: monospace;'>QMol_TDSE</span></a><span>).</span></div><h2  class = 'S2' id = 'H_24F205D3' ><span>Class properties</span></h2><h3  class = 'S5' id = 'H_5B03CB4B' ><span>Time propagation</span></h3><h4  class = 'S6' id = 'H_D8AAEC21' ><span style=' font-family: monospace;'>display (disp)</span></h4><div  class = 'S1'><span>Whether to display progress of the TDSE calculation as it goes on </span><span style=' font-family: monospace;'>[ true (default) | false ]</span></div><h4  class = 'S6' id = 'H_3B6C8431' ><span style=' font-family: monospace;'>time (T)</span></h4><div  class = 'S1'><span>Time propagation vector </span><span style=' font-family: monospace;'>[ vector (default []) ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>In all TDSE propagation simulations, </span><span style=' font-family: monospace;'>T(1)</span><span> specifies the starting time and </span><span style=' font-family: monospace;'>T(end)</span><span> the ending time.</span></li><li  class = 'S4'><span>In forward time propagation simulations (</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'> &gt; 0</span><span>), time values in </span><span style=' font-family: monospace;'>T</span><span> must be all increasing, while for backward time propagation (</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'> &lt; 0</span><span>) they must be all decreasing. Time increments in the vector </span><span style=' font-family: monospace;'>T</span><span> need not be equally spaced.</span></li><li  class = 'S4'><span>When </span><a href = "#H_D8AAEC21"><span style=' font-family: monospace;'>display</span></a><span> is activated, </span><span style=' font-family: monospace;'>T</span><span> specifies the intermediary times for the time-propagation progress display.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>T</span><span> is also the default time sampling for saved results that do not define their own.</span></li><li  class = 'S4'><span>Note that the time step used in TDSE propagations is set independently of </span><span style=' font-family: monospace;'>T</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_3CC0FE7C' ><span style=' font-family: monospace;'>timeStep (dt)</span></h4><div  class = 'S1'><span>Time step used for the time propagation </span><span style=' font-family: monospace;'> [ scalar (default 0.01) ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Positive (resp. negative) </span><span style=' font-family: monospace;'>timeStep</span><span> define forward (resp. backward) time propagation.</span></li></ul><h4  class = 'S6' id = 'H_56B22A57' ><span style=' font-family: monospace;'>splitMotif</span></h4><div  class = 'S1'><span>Splitting motif </span><span style=' font-family: monospace;'>[ 'VTV' (default) | 'TVT' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Whether the splitting starts with applying the potential (</span><span style=' font-family: monospace;'>'VTV'</span><span>) or kinetic (</span><span style=' font-family: monospace;'>'TVT'</span><span>)  part of the Schrödinger-equation Hamiltonian.</span></li></ul><h4  class = 'S6' id = 'H_85007098' ><span style=' font-family: monospace;'>absorbingBoundary (ABC)</span></h4><div  class = 'S1'><span>Absorber at the edges of the domain </span><span style=' font-family: monospace;'>[ [] (default) | mask object | CAP object ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>The boundary absorber aims at eliminating outgoing wave packets from the discretization domain and avoid spurious reflections at the edges of the domain.</span></li><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>absorbingBoundary</span><span> does not implement any absorbing boundary method and any part of the wave packet reaching the edges of the domain will be reflected (or articifially reappears on the other side of the domain through periodic effects).</span></li><li  class = 'S4'><span>Mask absorbers are applied at the end of each propagation step. They are the easiest to use and implement but are first order, irrespective of the order of the time propagation scheme. </span></li><li  class = 'S4'><span>Complex absorbing potentials (CAPs) are integrated within the propagation scheme, as an imaginary potential term that causes exponential decay of the wave packet at the edges. Under the right circumstances, CAPs can preserve the order of the propagation schemes. </span></li></ul><h4  class = 'S6' id = 'H_2EA3F8EC' ><span style=' font-family: monospace;'>externalField (EF)</span></h4><div  class = 'S1'><span>External driving field </span><span style=' font-family: monospace;'>[ [] (default) | </span><a href = "./QMol_extField_dipole.html"><span style=' font-family: monospace;'>QMol_extField_dipole</span></a><span style=' font-family: monospace;'> object ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>When performing the TDSE propagation, any </span><a href = "#H_35230E97"><span style=' font-family: monospace;'>electricField</span></a><span>, </span><a href = "#H_98CCC7E0"><span style=' font-family: monospace;'>electricFieldDerivative</span></a><span>, or </span><a href = "#H_054F0F9E"><span style=' font-family: monospace;'>potentialVector</span></a><span> are repackaged into </span><span style=' font-family: monospace;'>externalField</span><span>.</span></li><li  class = 'S4'><span>If no electric field or potential vector is defined, either through </span><span style=' font-family: monospace;'>externalField, </span><a href = "#H_35230E97"><span style=' font-family: monospace;'>electricField</span></a><span>, or </span><a href = "#H_054F0F9E"><span style=' font-family: monospace;'>potentialVector</span></a><span>, the TDSE propagation is performed field free.</span></li></ul><h4  class = 'S6' id = 'H_F8E58A47' ><span style=' font-family: monospace;'>externalFieldGauge (EFG)</span></h4><div  class = 'S1'><span>Gauge in which the external driving field is described </span><span style=' font-family: monospace;'>[ [] (default) | 'none' | 'length' | 'velocity' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>'none'</span><span> ignores any input external field and propagates the field-free TDSE dynamics.</span></li><li  class = 'S4'><span>The decision tree for the selection of the default gauge is detailed </span><a href = "#H_FD72E490"><span>below</span></a><span>.</span></li></ul><h4  class = 'S6' id = 'H_35230E97' ><span style=' font-family: monospace;'>electricField (FE)</span></h4><div  class = 'S1'><span>Electric field of the external driving field </span><span style=' font-family: monospace;'>[ [] (default) | function handle | griddedInterpolant ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>For developers: When initializing the class, non-empty </span><span style=' font-family: monospace;'>electricField</span><span> is moved into the </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span> property object (if needed creating the object first). During run time, </span><span style=' font-family: monospace;'>FE</span><span> contains the value of the electric field used in the propagation (where relevant).</span></li></ul><h4  class = 'S6' id = 'H_98CCC7E0' ><span style=' font-family: monospace;'>electricFieldDerivative (FDE)</span></h4><div  class = 'S1'><span>Derivative of the electric field of the external driving field </span><span style=' font-family: monospace;'>[ [] (default) | function handle | griddedInterpolant ]</span></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>griddedInterpolant</span><span> </span><span style=' font-family: monospace;'>electricFieldDerivative</span><span> is provided for general support but note that non-function-handle </span><a href = "#H_31F9A72A"><span>electric field derivatives are computed self-consistently</span></a><span> from the electric-field or potential-vector components.</span></li><li  class = 'S4'><span>For developers: When initializing the class, non-empty </span><span style=' font-family: monospace;'>electricFieldDerivative</span><span> is moved into the </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span> property object (if needed creating the object first). During run time, </span><span style=' font-family: monospace;'>FDE</span><span> contains the value of the derivative of the electric field used in the propagation (where relevant).</span></li></ul><h4  class = 'S6' id = 'H_054F0F9E' ><span style=' font-family: monospace;'>potentialVector (FA)</span></h4><div  class = 'S1'><span>Potential vector of the external driving field </span><span style=' font-family: monospace;'>[ [] (default) | function handle | griddedInterpolant ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>For developers: When initializing the class, non-empty </span><span style=' font-family: monospace;'>potentialVector</span><span> is moved into the </span><span style=' font-family: monospace;'>externalField</span><span> property object (if needed creating the object first). During run time, </span><span style=' font-family: monospace;'>FA</span><span> contains the value of the potential vector used in the propagation (where relevant).</span></li></ul><h4  class = 'S6' id = 'H_23189B60' ><span style=' font-family: monospace;'>diffDT</span></h4><div  class = 'S1'><span>Time step for used for computing time derivatives </span><span style=' font-family: monospace;'>[ nonnegative scalar (default 1e-5) ]</span></div><h3  class = 'S5' id = 'H_A211A946' ><span>Save the Schrödinger-equation object into individual files</span></h3><div  class = 'S1'><span>During the time propagation, copies of the Schrödinger-equation object can be saved in separate MATLAB files.</span></div><h4  class = 'S6' id = 'H_7A5FDD1F' ><span style=' font-family: monospace;'>saveSE (sSE)</span></h4><div  class = 'S1'><span>Activate saving the Schrödinger-equation object into separate files </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_4D9A3574' ><span style=' font-family: monospace;'>saveSEFileName (sSEF)</span></h4><div  class = 'S1'><span>Name for the files in which the Schrödinger-equation objects are saved </span><span style=' font-family: monospace;'>[ character array (default 'QMolGrid--TDSE--SE') ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>The Schrödinger-equation objects saved at different times are put in separate MATLAB (.mat.) file, with names starting with </span><span style=' font-family: monospace;'>saveSEFileName</span><span> to which the iteration index is appended. Each file produced also contains a scalar variable </span><span style=' font-family: monospace;'>t</span><span> with the time information.</span></li><li  class = 'S4'><span>One may specify a location where to create the files by indicating the folder path in </span><span style=' font-family: monospace;'>saveSEFileName</span><span>.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>saveSEFileName</span><span> is irrelevant when </span><a href = "#H_7A5FDD1F"><span style=' font-family: monospace;'>saveSE</span></a><span style=' font-family: monospace;'> == false</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_772A678B' ><span style=' font-family: monospace;'>saveSETime (sSET)</span></h4><div  class = 'S1'><span>Times at which to save the Schrödinger-equation object into a file </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveSETime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to save the Schrödinger-equation object into MATLAB files.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step when to save the Schrödinger-equation object into MATLAB files. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveSETime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward ones to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveSETime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between saves. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveSETime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveSETime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to save the Schrödinger-equation object to a MATLAB file.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> saves the Schrödinger-equation object into a MATLAB file after every time step. Warning: this is slow and may result in a very large number of file and/or large disk usage.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_A90EE811' ><span>Save the dipole, dipole velocity, and dipole acceleration signals</span></h3><h4  class = 'S6' id = 'H_E30347CB' ><span style=' font-family: monospace;'>saveDipole (sDip)</span></h4><div  class = 'S1'><span>Whether to calculate and save the dipole signal during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_9D21E9DE' ><span style=' font-family: monospace;'>saveDipoleWaveFunctionIndex (sDipI)</span></h4><div  class = 'S1'><span>Index of the wave functions for which to compute the dipole signal </span><span style=' font-family: monospace;'>[ [] (default) | index vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>This is irrelevant if </span><a href = "#H_E30347CB"><span style=' font-family: monospace;'>saveDipole</span></a><span> is </span><span style=' font-family: monospace;'>false</span><span>.</span></li><li  class = 'S4'><span>Specify the indexes of the wave functions for which to compute the orbital-resolved dipole signal in an index vector.</span></li><li  class = 'S4'><span>Empty or </span><span style=' font-family: monospace;'>'all'</span><span> </span><span style=' font-family: monospace;'>saveDipoleWaveFunctionIndex</span><span> computes the orbital-resolved dipole for all wave functions.</span></li></ul><h4  class = 'S6' id = 'H_CCC421C5' ><span style=' font-family: monospace;'>saveDipoleTime (sDipT)</span></h4><div  class = 'S1'><span>Times at which to compute and save the dipole signal </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveDipoleTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to compute and save the dipole signal.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive computations of the dipole signal. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveDipoleTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveDipoleTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between dipole-signal computations. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveDipoleTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveDipoleTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to compute and save the dipole signal.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> computes and saves the dipole signal after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h4  class = 'S6' id = 'H_2978977D' ><span style=' font-family: monospace;'>saveDipoleVelocity (sVel)</span></h4><div  class = 'S1'><span>Whether to calculate and save the dipole velocity signal during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_E363B1E2' ><span style=' font-family: monospace;'>saveDipoleVelocityWaveFunctionIndex (sVelI)</span></h4><div  class = 'S1'><span>Index of the wave functions for which to compute the orbital-resolved dipole velocity signal </span><span style=' font-family: monospace;'>[ [] (default) | index vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>This is irrelevant if </span><a href = "#H_2978977D"><span style=' font-family: monospace;'>saveDipoleVelocity</span></a><span> is </span><span style=' font-family: monospace;'>false</span><span>.</span></li><li  class = 'S4'><span>Specify the indexes of the wave functions for which to compute the dipole velocity signal in an index vector.</span></li><li  class = 'S4'><span>Empty or </span><span style=' font-family: monospace;'>'all'</span><span> </span><span style=' font-family: monospace;'>saveDipoleVelocityWaveFunctionIndex</span><span> computes the dipole velocity for all wave functions.</span></li></ul><h4  class = 'S6' id = 'H_FD864729' ><span style=' font-family: monospace;'>saveDipoleVelocityTime (sVelT)</span></h4><div  class = 'S1'><span>Times at which to compute and save the dipole velocity signal </span><span style=' font-family: monospace;'>[ 'dipole' (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>'dipole'</span><span> </span><span style=' font-family: monospace;'>saveDipoleVelocityTime</span><span> uses the same times as for </span><a href = "#H_CCC421C5"><span style=' font-family: monospace;'>saveDipoleTime</span></a><span>.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive computations of the dipole velocity signal. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveDipoleVelocityTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveDipoleVelocityTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between dipole-velocity-signal computations. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveDipoleVelocityTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveDipoleVelocityTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to compute and save the dipole velocity signal.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> computes and saves the dipole velocity signal after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h4  class = 'S6' id = 'H_CB35D0D0' ><span style=' font-family: monospace;'>saveDipoleAcceleration (sAcc)</span></h4><div  class = 'S1'><span>Whether to calculate and save the dipole acceleration signal during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_F7D56BC9' ><span style=' font-family: monospace;'>saveDipoleAccelerationWaveFunctionIndex (sAccI)</span></h4><div  class = 'S1'><span>Index of the wave functions for which to compute the dipole acceleration signal </span><span style=' font-family: monospace;'>[ [] (default) | index vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>This is irrelevant if </span><a href = "#H_CB35D0D0"><span style=' font-family: monospace;'>saveDipoleAcceleration</span></a><span> is </span><span style=' font-family: monospace;'>false</span><span>.</span></li><li  class = 'S4'><span>Specify the indexes of the wave functions for which to compute the dipole acceleration signal in an index vector.</span></li><li  class = 'S4'><span>Empty or </span><span style=' font-family: monospace;'>'all'</span><span> </span><span style=' font-family: monospace;'>saveDipoleAccelerationWaveFunctionIndex</span><span> computes the dipole acceleration for all wave functions.</span></li></ul><h4  class = 'S6' id = 'H_267F59C7' ><span style=' font-family: monospace;'>saveDipoleAccelerationTime (sAccT)</span></h4><div  class = 'S1'><span>Times at which to compute and save the dipole acceleration signal </span><span style=' font-family: monospace;'>[ 'dipole' (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>'dipole'</span><span> </span><span style=' font-family: monospace;'>saveDipoleAccelerationTime</span><span> uses the same times as for </span><a href = "#H_CCC421C5"><span style=' font-family: monospace;'>saveDipoleTime</span></a><span>.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive computations of the dipole acceleration signal. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveDipoleAccelerationTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveDipoleAccelerationTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between dipole-acceleration-signal computations. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveDipoleAccelerationTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveDipoleAccelerationTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to compute and save the dipole acceleration signal.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> computes and saves the dipole acceleration signal after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_FB7F0C94' ><span>Save Schrödinger-equation and wave function energies</span></h3><h4  class = 'S6' id = 'H_CB527D7D' ><span style=' font-family: monospace;'>saveEnergySE (sESE)</span></h4><div  class = 'S1'><span>Whether to track the Schrödinger-equation energy during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_D15EFD11' ><span style=' font-family: monospace;'>saveEnergySETime (sESET)</span></h4><div  class = 'S1'><span>Times at which to compute and save the Schrödinger-equation energy </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveEnergySETime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to compute and save the Schrödinger-equation energy</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive computations of the Schrödinger-equation energy. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveEnergySETime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveEnergySETime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between Schrödinger-equation-energy computations. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveEnergySETime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveEnergySETime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to compute and save the Schrödinger-equation energy.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> computes and saves the Schrödinger-equation energy after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h4  class = 'S6' id = 'H_6190C681' ><span style=' font-family: monospace;'>saveEnergyWaveFunction (sEWfcn)</span></h4><div  class = 'S1'><span>Whether to track the wave function energies during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>For a wave function </span><span texencoding="|\psi\rangle" style="vertical-align:-5px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAAAXNSR0IArs4c6QAABM5JREFUWEftWFtoHFUY/v6Z2dVdLai0pMSkM7O7JjaWWgUpKmh8EJK2NAi2FrVqG6pQ460vYhV9sVVf4qU2oNFCFWpFfUiNbaEPRvCOaBFMTd3MJdkE4h2qu92d2fnlwEwYl012N5eaYPdpOXPOP9/5zv//33eGsEh/tEhx4zzwc31y5xn/XzKuadqVRLTMcZxvMplMrhoSyqZKc3Pzknw+3ylJUsxxnIOjo6Pj1QSb6ZxkMnmD53nHmfl+y7IOVxOnLPCmpqaljuP0A1jueV67bdunqgk20zktLS0XZ7PZg2J9PB6/d3Bw8K9KsRYEcAFS07QtRPQWM2+0LOv4ogHe0NBweSQS6WfmbxVF2ZlOp/PTgV8wjLe2tiq2bb8AYBszr7Ms68tFAVyADIoUQK+qqo8PDAy4U4FfMIwLgEGREtEqWZbXpdPp4UUBPFSk7wB4yjTNvQC4HPiaGE8kEtcx8z4A1wL4GMDDpmkOhQOrqnqbLMtrmPnXbDZ7YGJi4m//Oamqeg0RPUhEbUT0dbFY3GXbthle39jYWK8oSp8Yc123YyoNqQm4CJZKpZLFYvEogCYAPbFY7LHBwcGCeCaEq1AovA2gA8A+VVV3+XlKuq5vBfAagBwzb7Ms68gUbIq5uwE8KzZpGEbPrBkXAerr6+PRaLSXiO4E8JnjOBszmczv4pmqqislSTom/gLYZJrm+6XjzPyMpml7pys8XddXAzjGzD+6rrspiB/eQM2MTwdc1/XbAbwHwA4p7iSDAE5XKjr/VC9wXbeHiMQp3WWapoj5r1/NwFOp1LJisShy8HoAQukesCzrrN+HuwE8BKAvGo1uHRoaOlMyvzcWi3UFqTVdn9Y0TdTBEWb+sJwNqBm4pmlriegEgCUAnvQrX+R+eEOT4+H5RNRpGMaBSnLud5flAPqJaGk5v1QzcF3XdwB4XQQnog2GYXzkvyjY0IXMfKtlWZ/4448Q0UsAzvjjX1UJfO4Yb2lpieZyuVcBCPCjsiy3p9PpH0oAnnQcZ0MmkxlLpVJBrm4H8IUsyx3pdPqXSsBD6+YmxxsaGi6LRCKijd0Y7iglBTuZxyWts7uSjAcbmvOuEvLpa5n5UKFQ2DE+Pp5VVVWXJEmkzMpQHotu0gXgFQB/VGOcAqEK9fEpa6KmHK+rq7soHo+/CeAOAO9ms9lOoYyJRGI9M4uLx8+e57XZtv2dYNt13T4iuoqZn9M07enpenfA9rwpZyKR2MnM+0M92dA0bQ8RPQHgBDNvVhTFKxaLYs7dRHQ4n893jY2N/VYpt8NeRcQzDEPY3Nl7FRFYOLhcLidA3eP38RclSepm5lsA7BdAmVmYoyuIaLckSYcqXQqCDc27OxRiY5rmalmWrwZwEzPf57/8Dc/zjkYikdPRaPSnaoQmfArn1I8nEontzCzy/pTneetL3V416SHmhG5AWwC0m6b5/XRrayrO0kDhvh7uMtWCDc8LWiczfzrvd87gggtA+O9HLct6eSagxRq/6J+XJKlteHj480pxZsW4pmk3+77lbC1yXgpKCJuiKMIB/jmr7yrVfsnyhWJPLXJejknfCX5ARJsD7zMjxistCoppZGRkDYBLBFMrVqw4WY3AlIudTCZXeZ536ay/HVYD/L+e8w9hgLlSy86goQAAAABJRU5ErkJggg==" width="23" height="18" /></span><span>, the orbital energy is defined as </span><span texencoding="\langle\psi|\hat{\mathcal{H}}|\psi\rangle" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="58" height="23" /></span><span> with </span><span texencoding="\hat{\mathcal{H}}" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="18" height="23" /></span><span> the Schrödinger-equation Hamiltonian operator.</span></li><li  class = 'S4'><span>In the velocity gauge, the external potential vector is accounted for in the kinetic-operator of </span><span texencoding="\hat{\mathcal{H}}" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="18" height="23" /></span><span> while, in the length gauge, the external electric field is ignored.</span></li><li  class = 'S4'><span>Note that the energy of all the wave functions are computed and saved. One may use an </span><a href = "#H_236395D1"><span>installable output function</span></a><span> to track the energy of a subset of wave functions.</span></li></ul><h4  class = 'S6' id = 'H_98DA6C1A' ><span style=' font-family: monospace;'>saveEnergyWaveFunctionTime (sEWfcnT)</span></h4><div  class = 'S1'><span>Times at which to compute and save the wave function energies </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveEnergyWaveFunctionTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to compute and save the wave fuction energies</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive computations of the wave function energies. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveEnergyWaveFunctionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveEnergyWaveFunctionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between wave-function-energy computations. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveEnergyWaveFunctionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveEnergyWaveFunctionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to compute and save the wave function energies.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> computes and saves the wave function energies after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_48DDF558' ><span>Save the external field information</span></h3><h4  class = 'S6' id = 'H_10596868' ><span style=' font-family: monospace;'>saveExternalField (sEF)</span></h4><div  class = 'S1'><span>For TDSE simulation with and </span><a href = "#H_2EA3F8EC"><span>external driving field</span></a><span>, save the external field in the output structures </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>When activated (</span><span style=' font-family: monospace;'>saveExternalField = true</span><span>), the information about the external driving field at the sampled times is added to each of the </span><a href = "#H_D533B953"><span>output structures</span></a><span>.</span></li><li  class = 'S4'><span>For practical reasons, the values for the external driving field may be slightly different from that of </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span>. This features enables keeping the actual external-field values used throughout the propagation.</span></li></ul><h3  class = 'S5' id = 'H_65D2E853' ><span>Save the ionization signal</span></h3><div  class = 'S1'><span>The ionization signal tracks how much density leaves the simulation domain by being </span><a href = "#H_85007098"><span>absorbed at the boundaries</span></a><span>.</span></div><h4  class = 'S6' id = 'H_6B566C83' ><span style=' font-family: monospace;'>saveIonization (sIon)</span></h4><div  class = 'S1'><span>Whether to calculate and save the ionization signal during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_07FC104D' ><span style=' font-family: monospace;'>saveIonizationWaveFunctionIndex (sIKSOI)</span></h4><div  class = 'S1'><span>Index of the wave functions for which to compute the orbital-resolved ionization signal </span><span style=' font-family: monospace;'>[ [] (default) | index vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>This is irrelevant if </span><a href = "#H_6B566C83"><span style=' font-family: monospace;'>saveIonization</span></a><span> is </span><span style=' font-family: monospace;'>false</span><span>.</span></li><li  class = 'S4'><span>Specify the indexes of the wave functions for which to compute the ionization signal in an index vector.</span></li><li  class = 'S4'><span>Empty or </span><span style=' font-family: monospace;'>'all'</span><span> </span><span style=' font-family: monospace;'>saveIonizationWaveFunctionIndex</span><span> computes the ionization for all wave functions.</span></li></ul><h4  class = 'S6' id = 'H_01E66AA1' ><span style=' font-family: monospace;'>saveIonizationTime (sIonT)</span></h4><div  class = 'S1'><span>Times at which to compute and save the ionization signal </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveIonizationTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to compute and save the ionization signal.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive computations of the ionization signal. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveIonizationTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveIonizationTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between ionization-signal computations. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveIonizationTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveIonizationTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to compute and save the ionization signal.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> computes and saves the ionization signal after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_E89C839B' ><span>Save the wave functions and their projection on a basis</span></h3><div  class = 'S1' id = 'M_5BAA8F46' ><span style=' text-decoration: underline;'>Warning:</span><span> The memory requirements for saving the wave functions throughout the TDSE propagation may grow very fast and trigger an error (if MATLAB runs out of memory). Instead, if the full wave function is required consider </span><a href = "#H_A211A946"><span>saving the Schrödinger-equation object in separate files</span></a><span>, or if only the result of a specify calculation on the wave functions is required consider consider using an installable </span><a href = "#H_236395D1"><span>output function</span></a><span>.</span></div><h4  class = 'S6' id = 'H_2A78E237' ><span style=' font-family: monospace;'>saveWaveFunction (sWfcn)</span></h4><div  class = 'S1'><span>Whether to save the wave functions during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_F26B9668' ><span style=' font-family: monospace;'>saveWaveFunctionIndex (sWfcnI)</span></h4><div  class = 'S1'><span>Index of the wave functions to save </span><span style=' font-family: monospace;'>[ [] (default) | index vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>This is irrelevant if </span><a href = "#H_2A78E237"><span style=' font-family: monospace;'>saveWaveFunction</span></a><span> is </span><span style=' font-family: monospace;'>false</span><span>.</span></li><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveWaveFunctionIndex</span><span> disables saving of the wave functions and is technically equivalent to </span><a href = "#H_2A78E237"><span style=' font-family: monospace;'>saveWaveFunction</span></a><span style=' font-family: monospace;'>= false</span><span>.</span></li><li  class = 'S4'><span>Specify the indexes of the wave functions to save in an index vector.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> saves all the wave functions.</span></li></ul><h4  class = 'S6' id = 'H_A93BF65C' ><span style=' font-family: monospace;'>saveWaveFunctionTime (sWfcnT)</span></h4><div  class = 'S1'><span>Times at which to save the wave functions </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveWaveFunctionTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to save the wave functions.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive saving of the wave functions. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveWaveFunctionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveWaveFunctionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between saving wave functions. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveWaveFunctionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveWaveFunctionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to save the wave functions.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> saves the wave functions after every time step. Warning: generally discouraged as it likely results in very large memory requirements or cause an out-of-memory error -- see the </span><a href = "#M_5BAA8F46"><span>warning above</span></a><span>.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h4  class = 'S6' id = 'H_0A85DA1C' ><span style=' font-family: monospace;'>saveWaveFunctionProjection (sWfcnP)</span></h4><div  class = 'S1'><span>Whether to save the projection of the wave functions onto a specific basis during the TDSE propagation </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_6BFEE12B' ><span style=' font-family: monospace;'>saveWaveFunctionProjectionBasis (sWfcnB)</span></h4><div  class = 'S1'><span>Projection basis </span><span style=' font-family: monospace;'>[ [] (default) | matrix basis | </span><a href = "./QMol_disc_basis.html"><span style=' font-family: monospace;'>QMol_disc_basis</span></a><span style=' font-family: monospace;'> ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveWaveFunctionProjectionBasis</span><span> uses the initial wave functions as the projection basis.</span></li><li  class = 'S4'><span>matrix </span><span style=' font-family: monospace;'>saveWaveFunctionProjectionBasis</span><span> specifies the projection basis to be used, with the projection vectors specified in each column of the matrix. </span></li><li  class = 'S4'><a href = "./QMol_disc_basis.html"><span style=' font-family: monospace;'>QMol_disc_basis</span></a><span> </span><span style=' font-family: monospace;'>saveWaveFunctionProjectionBasis</span><span> uses the basis set of the associated domain definition. </span></li><li  class = 'S4'><span>For both matrix and </span><a href = "./QMol_disc_basis.html"><span style=' font-family: monospace;'>QMol_disc_basis</span></a><span>, the user-defined basis set is assumed to be a proper orthonormal family defined over the same domain grid as the Schrödinger-equation model being propagated. The TDSE propagator </span><span style=' text-decoration: underline;'>does not</span><span> check for this and will produce erroneous results, or trigger an error, otherwise.</span></li></ul><h4  class = 'S6' id = 'H_44353F0D' ><span style=' font-family: monospace;'>saveWaveFunctionProjectionIndex (sWfcnPI)</span></h4><div  class = 'S1'><span>Index of the wave functions for which to perform the projection </span><span style=' font-family: monospace;'>[ [] (default) | index vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>This is irrelevant if </span><a href = "#H_0A85DA1C"><span style=' font-family: monospace;'>saveWaveFunctionProjection</span></a><span> is </span><span style=' font-family: monospace;'>false</span><span>.</span></li><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveWaveFunctionProjectionIndex</span><span> disables saving of the wave functions and is technically equivalent to </span><a href = "#H_0A85DA1C"><span style=' font-family: monospace;'>saveWaveFunctionProjection</span></a><span> </span><span style=' font-family: monospace;'>= false</span><span>.</span></li><li  class = 'S4'><span>Specify the indexes of the wave functions for which to perform the projection in an index vector.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> saves the projection for all the wave functions.</span></li></ul><h4  class = 'S6' id = 'H_71646414' ><span style=' font-family: monospace;'>saveWaveFunctionProjectionTime (sWfcnPT)</span></h4><div  class = 'S1'><span>Times at which to save the projection of the wave functions </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveWaveFunctionProjectionTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to save the projection of the wave functions.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive saving of the wave functions' projection. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveWaveFunctionProjectionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveWaveFunctionProjectionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between saving wave functions' projection. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveWaveFunctionProjectionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveWaveFunctionProjectionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to save the wave functions' projection.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> saves the wave functions' projection after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_236395D1' ><span>Save the output of a functions of the wave function</span></h3><div  class = 'S1'><span>This enables on-the-fly computation and saving of user-defined observables without having to save the Schrödinger-equation object or the wave functions.</span></div><h4  class = 'S6' id = 'H_13D0EA88' ><span style=' font-family: monospace;'>saveOutputFunction (sF)</span></h4><div  class = 'S1'><span>Installable output function of the wave functions </span><span style=' font-family: monospace;'>[ [] (default) | function handle ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Leave empty to disable the feature.</span></li><li  class = 'S4'><span>Provide a function handle to enable the feature. The signature for the function is </span><span style=' font-family: monospace;'>fun(wfcn,t)</span><span>, where </span><span style=' font-family: monospace;'>wfcn</span><span> is a wave function object and </span><span style=' font-family: monospace;'>t</span><span> is the time (scalar). The function handle may return an array of arbitrary size and shape, but must return at least a scalar and the shape of the output must remain constant throughout the TDSE propagation.</span></li><li  class = 'S4'><span style=' text-decoration: underline;'>Warning:</span><span> The Schrödinger-equation model wave functions are passed by reference to the output function. Thus modifying the wave functions in the output function will also modify them for the Schrödinger-equation model (and thus TDSE propagation) and will likely result in erroneous results or produce an error.</span></li></ul><h4  class = 'S6' id = 'H_B72B0D00' ><span style=' font-family: monospace;'>saveOutputFunctionTime (sFT)</span></h4><div  class = 'S1'><span>Times at which to evaluate and save the installable output function of the wave functions </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveOutputFunctionTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to evaluate and save the output function.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step between successive evaluation and saving of the output function. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveOutputFunctionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveOutputFunctionTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between evaluations and saving of the output function. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveOutputFunctionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveOutputFunctionTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to evaluate and save the output function.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> evaluates and saves the output function after every time step. Warning: this may be slow.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_5CD2979A' ><span>Save restart data file</span></h3><div  class = 'S1'><span>During the time propagation, a restart file can be generated to enable resuming the simulation if it is cut short. Stopping the TDSE simulation while it writes the restart info may lead to a corrupted file from which restart will not be possible. The restart file contains a copy of the TDSE-propagator and Schrödinger-equation-model objects, respectively called </span><span style=' font-family: monospace;'>TDSE</span><span> and </span><span style=' font-family: monospace;'>SE</span><span>.</span></div><h4  class = 'S6' id = 'H_06F9031D' ><span style=' font-family: monospace;'>saveRestart (sRest)</span></h4><div  class = 'S1'><span>Activate the generation of a restart file </span><span style=' font-family: monospace;'>[ true | false (default) ]</span></div><h4  class = 'S6' id = 'H_AE8821C0' ><span style=' font-family: monospace;'>saveRestartFileName (sRestF)</span></h4><div  class = 'S1'><span>Name for the restart file </span><span style=' font-family: monospace;'>[ chracter array (default 'QMolGrid--TDSE--Restart.mat') ]</span></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>saveRestartFileName</span><span> must be a valid MATLAB file name ('.mat' extension).</span></li><li  class = 'S4'><span style=' font-family: monospace;'>saveRestartFileName</span><span> is irrelevant when </span><a href = "#H_06F9031D"><span style=' font-family: monospace;'>saveRestart</span></a><span style=' font-family: monospace;'> == false</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_5668813B' ><span style=' font-family: monospace;'>saveRestartTime (sRestT)</span></h4><div  class = 'S1'><span>Times at which to generate or update the restart file </span><span style=' font-family: monospace;'>[ [] (default) | positive scalar | negative integer | vector | 'all' ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>Empty </span><span style=' font-family: monospace;'>saveRestartTime</span><span> uses the same values as in </span><a href = "#H_3B6C8431"><span style=' font-family: monospace;'>time</span></a><span> for when to generate and update the restart file.</span></li><li  class = 'S4'><span>A positive scalar specifies the sampling time step when to generate and update the restart file. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):saveRestartTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-saveRestartTime:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A negative integer specifies the number of propagation time steps between the generation and update of the restart file. For forward time propagation, it is equivalent to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):abs(saveRestartTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>, and for backward one to </span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(1):-abs(saveRestartTime)*</span><a href = "#H_3CC0FE7C"><span style=' font-family: monospace;'>timeStep</span></a><span style=' font-family: monospace;'>:</span><a href = "#H_3B6C8431"><span>time</span></a><span style=' font-family: monospace;'>(end)</span><span>.</span></li><li  class = 'S4'><span>A vector provides user-defined times at which to generate and update the restart file.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>'all'</span><span> generates and updates the restart file after each time step. Warning: this is very slow and is strongly discouraged.</span></li><li  class = 'S4'><span style=' text-decoration: underline;'>Note:</span><span> In all cases, no restart file is generated for the initial time and final propagation time step.</span></li><li  class = 'S4'><span>See the note on how intermediate time saving is performed during the TDSE propagation </span><a href = "#M_16F59492"><span>below</span></a><span>.</span></li></ul><h3  class = 'S5' id = 'H_D533B953' ><span>Output results</span></h3><div  class = 'S1' id = 'M_16F59492' ><span>During a TDSE propagation, the results of on-the-fly calculations are strored in structures in the </span><span style=' font-family: monospace;'>QMol_TDSE</span><span> object. Note that </span><span style=' font-family: monospace;'>QMol_TDSE</span><span> does </span><span style=' text-decoration: underline;'>not</span><span> interpolate its time propagation to fit user-supplied sample times, Insatead, the results are saved at the closest propagation time steps, excluding duplicate times. This may result in sampled times that are different, or have a different (smaller) number of elements, from the ones specified above. Notably, using a sampling time that is not a multiple of the propagation time step may result in uneven saved time sampling. The actual times at with output are saved is included in each of the output structure.</span></div><div  class = 'S1'><span>When </span><a href = "#H_10596868"><span style=' font-family: monospace;'>saveExternalField</span></a><span> is </span><span style=' font-family: monospace;'>true</span><span>, each output-result structure includes the following fields:</span></div><ul  class = 'S3'><li  class = 'S4'><span>In the length gauge, </span><span style=' font-family: monospace;'>outStructure.electricField</span><span> contains the specific values for the electric field used in the TDSE propagation at the saved times.</span></li><li  class = 'S4'><span>In the velocity gauge, </span><span style=' font-family: monospace;'>outStructure.potentialVector</span><span> contains the specific values for the potential vector used in the TDSE propagation at the saved times.</span></li><li  class = 'S4'><span>In all cases, if the potential vector, electric field, or derivative of the electric field are calculated by the propagator during the simulations (see the decision tree </span><a href = "#H_31F9A72A"><span>below</span></a><span>), those are included in </span><span style=' font-family: monospace;'>outStructure.potentialVector</span><span>, </span><span style=' font-family: monospace;'>outStructure.electricField</span><span>, and </span><span style=' font-family: monospace;'>outStructure.electricFieldDerivative</span><span>, respectively</span></li></ul><div  class = 'S1'><span>In </span><a href = "#H_5CD2979A"><span>restart mode</span></a><span>, each of the output structure contains a handful of additional fields to the ones listed below that are relevant for run-time calculations. These fields are saved in the MATALB restart file but removed upon completion of the TDSE propagation.</span></div><h4  class = 'S6' id = 'H_F65810AA' ><span style=' font-family: monospace;'>outDipole (oDip)</span></h4><div  class = 'S1'><span>Result of dipole-signal calculations during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does not compute the dipole signal (</span><a href = "#H_E30347CB"><span style=' font-family: monospace;'>saveDipole</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outDipole</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outDipole.time</span><span> defines the precise times at which the dipole signal is computed.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outDipole.waveFunction_x</span><span> contains the dipole signal for selected wave functions. The indices of the wave functions associated with each of these are included in </span><span style=' font-family: monospace;'>outDipole.indexWaveFunction</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_95407807' ><span style=' font-family: monospace;'>outDipoleVelocity (oVel)</span></h4><div  class = 'S1'><span>Result of dipole-velocity-signal calculations during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does not compute the dipole signal (</span><a href = "#H_2978977D"><span style=' font-family: monospace;'>saveDipoleVelocity</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outDipoleVelocity</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outDipoleVelocity.time</span><span> defines the precise times at which the dipole velocity signal is computed.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outDipoleVelocity.waveFunction_x</span><span> contains the dipole signal for selected wave functions. The indices of the wave functions associated with each of these are included in </span><span style=' font-family: monospace;'>outDipoleVelocity.indexWaveFunction</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_02629977' ><span style=' font-family: monospace;'>outDipoleAcceleration (oAcc)</span></h4><div  class = 'S1'><span>Result of dipole-acceleration-signal calculations during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does not compute the dipole signal (</span><a href = "#H_CB35D0D0"><span style=' font-family: monospace;'>saveDipoleAcceleration</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outDipoleAcceleration</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outDipoleAcceleration.time</span><span> defines the precise times at which the dipole acceleration signal is computed.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outDipoleVelocity.waveFunction_x</span><span> contains the dipole signal for selected wave functions. The indices of the wave functions associated with each of these are included in </span><span style=' font-family: monospace;'>outDipoleAcceleration.indexWaveFunction</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_B6B04F7C' ><span style=' font-family: monospace;'>outEnergySE (oESE)</span></h4><div  class = 'S1'><span>Result of the Schrödinger-equation-energy calculations during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does track the Schrödinger-equation energy (</span><a href = "#H_CB527D7D"><span style=' font-family: monospace;'>saveEnergySE</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outEnergySE</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergySE.time</span><span> defines the precise times at which the Schrödinger-equation energies are computed.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergySE.total</span><span> contains the total Schrödinger-equation energy, which should be constant (within the precision of the propagation scheme).</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergySE.kinetic</span><span> contains the kinetic-energy component, including the driving-field potential vector in the velocity gauge. </span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergySE.potential</span><span> contains the potential-energy component. </span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergySE.externalField</span><span> contains the energy contribution from the driving electric field in the length gauge.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergySE.autonomization</span><span> contains the energy brought in and out of the system by the </span><a href = "#H_2EA3F8EC"><span>external driving field</span></a><span> (if any).</span></li></ul><h4  class = 'S6' id = 'H_71BECE2C' ><span style=' font-family: monospace;'>outEnergyWaveFunction (oEWfcn)</span></h4><div  class = 'S1'><span>Result of the wave-function-energy calculations during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does track the Schrödinger-equation energy (</span><a href = "#H_6190C681"><span style=' font-family: monospace;'>saveEnergyWaveFunction</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outEnergyWaveFunction</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span>For a wave function </span><span texencoding="|\psi\rangle" style="vertical-align:-5px"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAkCAYAAAD2IghRAAAAAXNSR0IArs4c6QAABM5JREFUWEftWFtoHFUY/v6Z2dVdLai0pMSkM7O7JjaWWgUpKmh8EJK2NAi2FrVqG6pQ460vYhV9sVVf4qU2oNFCFWpFfUiNbaEPRvCOaBFMTd3MJdkE4h2qu92d2fnlwEwYl012N5eaYPdpOXPOP9/5zv//33eGsEh/tEhx4zzwc31y5xn/XzKuadqVRLTMcZxvMplMrhoSyqZKc3Pzknw+3ylJUsxxnIOjo6Pj1QSb6ZxkMnmD53nHmfl+y7IOVxOnLPCmpqaljuP0A1jueV67bdunqgk20zktLS0XZ7PZg2J9PB6/d3Bw8K9KsRYEcAFS07QtRPQWM2+0LOv4ogHe0NBweSQS6WfmbxVF2ZlOp/PTgV8wjLe2tiq2bb8AYBszr7Ms68tFAVyADIoUQK+qqo8PDAy4U4FfMIwLgEGREtEqWZbXpdPp4UUBPFSk7wB4yjTNvQC4HPiaGE8kEtcx8z4A1wL4GMDDpmkOhQOrqnqbLMtrmPnXbDZ7YGJi4m//Oamqeg0RPUhEbUT0dbFY3GXbthle39jYWK8oSp8Yc123YyoNqQm4CJZKpZLFYvEogCYAPbFY7LHBwcGCeCaEq1AovA2gA8A+VVV3+XlKuq5vBfAagBwzb7Ms68gUbIq5uwE8KzZpGEbPrBkXAerr6+PRaLSXiO4E8JnjOBszmczv4pmqqislSTom/gLYZJrm+6XjzPyMpml7pys8XddXAzjGzD+6rrspiB/eQM2MTwdc1/XbAbwHwA4p7iSDAE5XKjr/VC9wXbeHiMQp3WWapoj5r1/NwFOp1LJisShy8HoAQukesCzrrN+HuwE8BKAvGo1uHRoaOlMyvzcWi3UFqTVdn9Y0TdTBEWb+sJwNqBm4pmlriegEgCUAnvQrX+R+eEOT4+H5RNRpGMaBSnLud5flAPqJaGk5v1QzcF3XdwB4XQQnog2GYXzkvyjY0IXMfKtlWZ/4448Q0UsAzvjjX1UJfO4Yb2lpieZyuVcBCPCjsiy3p9PpH0oAnnQcZ0MmkxlLpVJBrm4H8IUsyx3pdPqXSsBD6+YmxxsaGi6LRCKijd0Y7iglBTuZxyWts7uSjAcbmvOuEvLpa5n5UKFQ2DE+Pp5VVVWXJEmkzMpQHotu0gXgFQB/VGOcAqEK9fEpa6KmHK+rq7soHo+/CeAOAO9ms9lOoYyJRGI9M4uLx8+e57XZtv2dYNt13T4iuoqZn9M07enpenfA9rwpZyKR2MnM+0M92dA0bQ8RPQHgBDNvVhTFKxaLYs7dRHQ4n893jY2N/VYpt8NeRcQzDEPY3Nl7FRFYOLhcLidA3eP38RclSepm5lsA7BdAmVmYoyuIaLckSYcqXQqCDc27OxRiY5rmalmWrwZwEzPf57/8Dc/zjkYikdPRaPSnaoQmfArn1I8nEontzCzy/pTneetL3V416SHmhG5AWwC0m6b5/XRrayrO0kDhvh7uMtWCDc8LWiczfzrvd87gggtA+O9HLct6eSagxRq/6J+XJKlteHj480pxZsW4pmk3+77lbC1yXgpKCJuiKMIB/jmr7yrVfsnyhWJPLXJejknfCX5ARJsD7zMjxistCoppZGRkDYBLBFMrVqw4WY3AlIudTCZXeZ536ay/HVYD/L+e8w9hgLlSy86goQAAAABJRU5ErkJggg==" width="23" height="18" /></span><span>, the energy is defined as </span><span texencoding="\langle\psi|\hat{\mathcal{H}}|\psi\rangle" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="58" height="23" /></span><span> with </span><span texencoding="\hat{\mathcal{H}}" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="18" height="23" /></span><span> the Schrödinger-equation Hamiltonian operator. In the velocity gauge, the external potential vector is accounted for in the kinetic-operator of </span><span texencoding="\hat{\mathcal{H}}" style="vertical-align:-5px"><img src="data:image/png;base64,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" width="18" height="23" /></span><span> while, in the length gauge, the external electric field is ignored.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outEnergyWaveFunction.time</span><span> defines the precise times at which the wave function energies are computed.</span></li><li  class = 'S4'><span>Each row of </span><span style=' font-family: monospace;'>outEnergyWaveFunction.waveFunction</span><span> contains the energies of the corresponding wave functions.</span></li></ul><h4  class = 'S6' id = 'H_E1C662FA' ><span style=' font-family: monospace;'>outIonization (oIon)</span></h4><div  class = 'S1'><span>Result of the ionization calculations during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does track ionization (</span><a href = "#H_6B566C83"><span style=' font-family: monospace;'>saveIonization</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outIonization</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outIonization.time</span><span> defines the precise times at which the ionization is computed.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outIonization.waveFunction</span><span> contains the ionization for the selected wave functions. The indices of the wave functions associated with each of these are included in </span><span style=' font-family: monospace;'>outIonization.indexWaveFunction</span><span>.</span></li></ul><h4  class = 'S6' id = 'H_371940E8' ><span style=' font-family: monospace;'>outWaveFunction (oWfcn)</span></h4><div  class = 'S1'><span>Wave functions during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does not save the wave function (</span><a href = "#H_2A78E237"><span style=' font-family: monospace;'>saveWaveFunction</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outWaveFunction</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span>The specific shape of the saved wave functions is implementation dependent -- see the corresponding documentation for details. At minimum, each implementation defines:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outWaveFunction.time</span><span> defines the precise times at which the wave functions are saved.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outWaveFunction.waveFunction</span><span> contains the saved wave functions and </span><span style=' font-family: monospace;'>outWaveFunction.indexWaveFunction</span><span> the corresponding wave-function indices.</span></li></ul><h4  class = 'S6' id = 'H_5096ABA5' ><span style=' font-family: monospace;'>outWaveFunctionProjection (oWfcnP)</span></h4><div  class = 'S1'><span>Projection of the wave functions during the TDSE propagation </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does not save the projection of the wave functions (</span><a href = "#H_0A85DA1C"><span style=' font-family: monospace;'>saveWaveFunctionProjection</span></a><span style=' font-family: monospace;'> = false</span><span>) leaves </span><span style=' font-family: monospace;'>outWaveFunctionProjection</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span>The specific shape of the saved wave functions' projection is implementation dependent -- see the corresponding documentation for details. At minimum, each implementation defines:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outWaveFunctionProjection.time</span><span> defines the precise times at which the wave function projections are saved.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outWaveFunctionProjection.waveFunction</span><span> contains the saved wave functions' projection and </span><span style=' font-family: monospace;'>outWaveFunctionProjection.indexWaveFunction</span><span> the corresponding wave function indices.</span></li><li  class = 'S4'><span>The structure also retains a copy of the projection basis as </span><a href = "./QMol_disc_basis.html"><span style=' font-family: monospace;'>QMol_disc_basis</span></a><span> object(s).</span></li></ul><h4  class = 'S6' id = 'H_25C1C7F6' ><span style=' font-family: monospace;'>outOutputFunction (oF)</span></h4><div  class = 'S1'><span>Result of the installable output function of the wave functions </span><span style=' font-family: monospace;'>[ [] | structure ]</span></div><ul  class = 'S3'><li  class = 'S4'><span>TDSE propagation that does not define an installabe output function (</span><a href = "#H_13D0EA88"><span style=' font-family: monospace;'>saveOutputFunction</span></a><span style=' font-family: monospace;'> = []</span><span>) leaves </span><span style=' font-family: monospace;'>outOutputFunction</span><span> empty. Otherwise:</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outOutputFunction.time</span><span> defines the precise times at which the result of the output function is saved.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outOutputFunction.result</span><span> contains the results of the output function. If the installable function returns a scalar or a column vector, </span><span style=' font-family: monospace;'>outOutputFunction.result</span><span> is a </span><span style=' font-family: monospace;'>N-by-numel(outOutputFunction.time)</span><span> matrix with </span><span style=' font-family: monospace;'>N</span><span> the numer of elements in the output. Otherwise, </span><span style=' font-family: monospace;'>outOutputFunction.result</span><span> is an </span><span style=' font-family: monospace;'>M-by-numel(outOutputFunction.time)</span><span> array with </span><span style=' font-family: monospace;'>M</span><span> the size of the output.</span></li><li  class = 'S4'><span style=' font-family: monospace;'>outOutputFunction.shape</span><span> contains the shape of the output function (</span><span style=' font-family: monospace;'>N</span><span> or </span><span style=' font-family: monospace;'>M</span><span>, as defined in the previous bullet point).</span></li></ul><h2  class = 'S2' id = 'H_444F9B6D' ><span>Class methods</span></h2><h3  class = 'S5' id = 'H_A7EA7D3E' ><span>Creation</span></h3><h4  class = 'S6' id = 'H_0783E8B1' ><span>constructor</span></h4><div  class = 'S1'><span>Create a sixth-order optimized Blanes and Moan [</span><a href = "#M_2A8D1A6C"><span>Blanes 2002</span></a><span>] symplectic TDSE-propagator object with empty class properties.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj = QMol_TDSE_SSO_6BM;</span></span></div></div></div><div  class = 'S8'><span>Create a TDSE-propagator object with the </span><span style=' font-family: monospace;'>name</span><span> properties set to the specified </span><span style=' font-family: monospace;'>value</span><span>. Several </span><span style=' font-family: monospace;'>name-value</span><span> pairs can be specified consecutively. Suitable </span><span style=' font-family: monospace;'>name</span><span> is any of the TDSE </span><a href = "#H_24F205D3"><span>class properties</span></a><span> and is case insensitive.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >obj = QMol_TDSE_SSO_6BM(name1,value1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre"><span >obj = QMol_TDSE_SSO_6BM(name1,value1,name2,value2,</span><span style="color: rgb(225, 27, 20);">___</span><span >);</span></span></div></div></div><h3  class = 'S5' id = 'H_87F4F901' ><span>Changing class properties</span></h3><h4  class = 'S6' id = 'H_4405B79D' ><span style=' font-family: monospace;'>set</span></h4><div  class = 'S1'><span>Update the </span><span style=' font-family: monospace;'>name</span><span> properties of a TDSE-model object to the specified </span><span style=' font-family: monospace;'>value</span><span>. Several </span><span style=' font-family: monospace;'>name-value</span><span> pairs can be specified consecutively. Suitable </span><span style=' font-family: monospace;'>name</span><span> is any of the TDSE </span><a href = "#H_24F205D3"><span>class properties</span></a><span> and is case insensitive. In restart mode, </span><a href = "#H_D533B953"><span>output result</span></a><span> structures can also be edited with </span><span style=' font-family: monospace;'>set</span><span>. </span><span style=' font-family: monospace;'>QMol_TDSE</span><span> does not check the integrity of its input/output component during a restart and this feature should only be considered by advanced users.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >obj.set(name1,value1);</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre"><span >obj.set(name1,value1,name2,value2,</span><span style="color: rgb(225, 27, 20);">___</span><span >);</span></span></div></div></div><div  class = 'S8'><span>This is the common name-value pair assignment method used throughout the QMol-grid package.</span></div><h4  class = 'S6' id = 'H_C729A888' ><span style=' font-family: monospace;'>clear</span></h4><div  class = 'S1'><span>Clear all class properties.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj.clear;</span></span></div></div></div><div  class = 'S8'><span>Clear a specific set of the class properties. Suitable </span><span style=' font-family: monospace;'>name</span><span> is any of the TDSE </span><a href = "#H_24F205D3"><span>class properties</span></a><span> and is case insensitive.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj.clear(name1,name2,</span><span style="color: rgb(225, 27, 20);">___</span><span >);</span></span></div></div></div><div  class = 'S8'><span>This is the common </span><span style=' font-family: monospace;'>clear</span><span> method available to all classes throughout the QMol-grid package. The </span><span style=' font-family: monospace;'>clear</span><span> method can be used to delete specific properties before saving an instance of the TDSE propagators class and propagation results.</span></div><h3  class = 'S5' id = 'H_686ACD09' ><span>Initializing the object</span></h3><h4  class = 'S6' id = 'H_85EFED0A' ><span style=' font-family: monospace;'>initialize</span></h4><div  class = 'S1'><span>Initialize a sixth-order optimized Blanes and Moan [</span><a href = "#M_2A8D1A6C"><span>Blanes 2002</span></a><span>] symplectic TDSE-propagator object without allocating the </span><a href = "#H_D533B953"><span>output-result</span></a><span> structures.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj.initialize(SE);</span></span></div></div></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>SE</span><span> is the </span><a href = "./SE.html"><span>Schrödinger-equation-model</span></a><span> handle object, </span><span style=' font-style: italic;'>i.e.</span><span>, </span><a href = "./QMol_SE.html"><span style=' font-family: monospace;'>QMol_SE</span></a><span>, that describes the Schrödinger-equation systems to propagate.</span></li><li  class = 'S4'><span style=' text-decoration: underline;'>For developers:</span><span> </span><span style=' font-family: monospace;'>initialize</span><span> also has a specific interface when called from the </span><a href = "#H_5CD9DA16"><span style=' font-family: monospace;'>propagate</span></a><span> method that initializes the absorbing boundaries (if any) and determines whether the </span><a href = "#H_D533B953"><span>output-result</span></a><span> structures should be initialized too. Overloading classes should avoid redefining </span><span style=' font-family: monospace;'>initialize</span><span>; If the overloading class needs to perform some initialization (at the beginning of a TDSE propagation or upon restart), overload the </span><span style=' font-family: monospace;'>initializeChildren</span><span> method instead.</span></li></ul><h3  class = 'S5' id = 'H_B2D31FE3' ><span>Run-time documentation</span></h3><h4  class = 'S6' id = 'H_E3988947' ><span style=' font-family: monospace;'>getMemoryProfile</span></h4><div  class = 'S1'><span>Get an estimate of the memory help by a </span><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> object with either</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >mem = obj.getMemoryProfile;</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre"><span >mem = obj.getMemoryProfile(false);</span></span></div></div></div><ul  class = 'S3'><li  class = 'S4'><span>The object must be </span><a href = "#H_85EFED0A"><span style=' font-family: monospace;'>initialize</span></a><span>d for the memory footprint evaluation. If not arleady, </span><span style=' font-family: monospace;'>getMemoryProfile</span><span> initializes the Schrödinger-equation model object.</span></li><li  class = 'S4'><span>The estimate includes the (1) Schrödinger-equation model, (2) TDSE propagator, and (3) </span><a href = "#H_D533B953"><span>output results</span></a><span>. Note that all these components may not be used in actual simulations and the memory estimate tries to be conservative. On the other hand, it only includes the discretization of member components on the domain grid and ignores other (expectedly small) properties.</span></li><li  class = 'S4'><span>The output </span><span style=' font-family: monospace;'>mem</span><span> is the estimated size in bytes.</span></li></ul><div  class = 'S1'><span>Additionally display the detail of the memory footprint with</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >mem = obj.getMemoryProfile(true);</span></span></div></div></div><h4  class = 'S6' id = 'H_ABD08C91' ><span style=' font-family: monospace;'>showDocumentation</span></h4><div  class = 'S1'><span>Display the run-time documentation for the specific configuration of a </span><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> object, wich must have been </span><a href = "#H_85EFED0A"><span style=' font-family: monospace;'>initialize</span></a><span>d beforehand</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj.showDocumentation;</span></span></div></div></div><h3  class = 'S5' id = 'H_AEFB66DB' ><span>TDSE propagation</span></h3><h4  class = 'S6' id = 'H_5CD9DA16' ><span style=' font-family: monospace;'>propagate</span></h4><div  class = 'S1'><span>Propagate the TDSE dynamics starting from a Schrödinger-equation model object (from scratch).</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj.propagate(SE);</span></span></div></div></div><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>SE</span><span> is the </span><a href = "./SE.html"><span>Schrödinger-equation-model</span></a><span> handle object, </span><span style=' font-style: italic;'>i.e.</span><span>, </span><a href = "./QMol_SE.html"><span style=' font-family: monospace;'>QMol_SE</span></a><span>, that describes the Schrödinger-equation systems to propagate.</span></li><li  class = 'S4'><span>Neither the TDSE-propagation </span><span style=' font-family: monospace;'>obj</span><span> nor the Schrödinger-equation-model </span><span style=' font-family: monospace;'>SE</span><span> objects need be </span><a href = "#H_85EFED0A"><span style=' font-family: monospace;'>initialize</span></a><span>d. In all cases both are (re)initialized at the beginning of the TDSE propagation to ensure proper and consistent linkage and setup between them.</span></li></ul><div  class = 'S1'><span>Restart a TDSE propagation.</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S7'><span style="white-space: pre"><span >obj.propagate(</span><span style="color: #a709f5;">'restart'</span><span >);</span></span></div></div></div><ul  class = 'S3'><li  class = 'S4'><span>This can be performed after loading the corresponding restart MATLAB file into the workspace.</span></li></ul><h4  class = 'S6' id = 'H_FD72E490' ><span>Choice of gauge</span></h4><div  class = 'S1'><span>If no specific gauge is specified with </span><a href = "#H_F8E58A47"><span style=' font-family: monospace;'>externalFieldGauge</span></a><span>, the gauge is selected following the decision tree:</span></div><ul  class = 'S3'><li  class = 'S4'><span>Length gauge if </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> or </span><a href = "#H_35230E97"><span style=' font-family: monospace;'>electricField</span></a><span> is a function handle, otherwise:</span></li><li  class = 'S4'><span>Velocity gauge if </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span> or </span><a href = "#H_054F0F9E"><span style=' font-family: monospace;'>potentialVector</span></a><span> is a function handle, otherwise:</span></li><li  class = 'S4'><span>Length gauge if </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> or </span><a href = "#H_35230E97"><span style=' font-family: monospace;'>electricField</span></a><span> is a </span><span style=' font-family: monospace;'>griddedInterpolant</span><span>, otherwise:</span></li><li  class = 'S4'><span>Velocity gauge if </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span> or </span><a href = "#H_054F0F9E"><span style=' font-family: monospace;'>potentialVector</span></a><span> is a </span><span style=' font-family: monospace;'>griddedInterpolant</span><span>, otherwise:</span></li><li  class = 'S4'><span>Field free (ignore any input field).</span></li></ul><h4  class = 'S6' id = 'H_31F9A72A' ><span>External-field components used in simulations</span></h4><div  class = 'S1'><span>Depending on the types of input, not all provided external-field may be used in the simulations. For the potential vector and electric field -- recall that </span><a href = "#H_35230E97"><span style=' font-family: monospace;'>electricField</span></a><span> and </span><a href = "#H_054F0F9E"><span style=' font-family: monospace;'>potentialVector</span></a><span> are repackaged into </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span> at the beginning of the simulation: </span></div><ul  class = 'S3'><li  class = 'S4'><span>If both are provided as function handles, then </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> and </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span> are called whenever the values for the potential vector or electric field are required. Note that the TDSE propagator does </span><span style=' text-decoration: underline;'>not</span><span> check whether the provided potential vector and electric field are consistent with each other (</span><span texencoding="E(t)=-\partial_t A(t)" style="vertical-align:-6px"><img src="data:image/png;base64,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" width="92.5" height="19.5" /></span><span>) and providing non-matching components will likely result in erroneous results. Otherwise,</span></li><li  class = 'S4'><span>If only one of them is provided as a function handle, then both the potential vector and electric field are computed from that same function handle (see </span><a href = "#M_0A78CFE1"><span>below</span></a><span> for details on how this is done). Otherwise,</span></li><li  class = 'S4'><span>In the length gauge, if </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> is a </span><span style=' font-family: monospace;'>griddedInterpolant</span><span> then it is used to compute both the electric field and potential vector, otherwise, </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span> is used to compute them both.</span></li><li  class = 'S4'><span>In the velocity gauge, if </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span> is a </span><span style=' font-family: monospace;'>griddedInterpolant</span><span> then it is used to compute both the electric field and potential vector, otherwise, </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> is used to compute them both.</span></li><li  class = 'S4'><span>If none of the </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> and </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span> are defined, the TDSE propagation is performed field free irrespective of the choice of </span><a href = "#H_F8E58A47"><span style=' font-family: monospace;'>externalFieldGauge</span></a><span> and even if an </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricFieldDerivative</span><span> is defined.</span></li></ul><div  class = 'S1'><span>The choice of ignoring some (interpolated) input fields is made to ensure the self-consistency of the TDSE dynamics, and associated observables, during the numerical propagation. To force using an interpolated field input, one can encapsulate it into a function handle </span><span style=' font-family: monospace;'>@(t) interpolatedField(t)</span><span>. </span></div><div  class = 'S1'><span>For the electric-field derivative:</span></div><ul  class = 'S3'><li  class = 'S4'><span>If </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricFieldDerivative</span><span> is defined as a function handle, then </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricFieldDerivative</span><span> is called when the derivative of the electric field is required.</span></li><li  class = 'S4'><span>Otherwise the electric-field derivative is numerically computed from </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.electricField</span><span> or </span><a href = "#H_2EA3F8EC"><span style=' font-family: monospace;'>externalField</span></a><span style=' font-family: monospace;'>.potentialVector</span><span>, depending on which field component(s) are being used in the TDSE propagation. </span></li></ul><div  class = 'S1' id = 'M_0A78CFE1' ><span>Numerical computation of missing or ignored field components:</span></div><ul  class = 'S3'><li  class = 'S4'><span>Where required, the potential vector is computed from the electric field using a Simpson's 1/3 quadrature rule.</span></li><li  class = 'S4'><span>Where required, the electric field is computed from the potential vector using a second-order centered finite difference with </span><a href = "#H_23189B60"><span style=' font-family: monospace;'>diffDT</span></a><span> time step.</span></li><li  class = 'S4'><span>Where required, the electric field derivative is computed from the electric field or the potential vector using a second-order centered finite difference with </span><a href = "#H_23189B60"><span style=' font-family: monospace;'>diffDT</span></a><span> time step.</span></li></ul><h2  class = 'S2'><span>Examples</span></h2><div  class = 'S1'><span>See the </span><a href = "./TDDFT.html"><span>main documentation page</span></a><span> for examples of TDSE simulations with various output computations.</span></div><h2  class = 'S2' id = 'H_D431B55B' ><span>Test suite</span></h2><div  class = 'S1'><span>For consistency with the rest of the QMol-grid package, </span><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> defines an associated test suite. Run the test suite for the class in normal or </span><a href = "./Test_suite.html"><span>summary mode</span></a><span> respectively with</span></div><div class="CodeBlock"><div class="inlineWrapper"><div  class = 'S9'><span style="white-space: pre"><span >QMol_test.test(</span><span style="color: #a709f5;">'TDSE_SSO_6BM'</span><span >);</span></span></div></div><div class="inlineWrapper"><div  class = 'S10'><span style="white-space: pre"><span >QMol_test.test(</span><span style="color: #a709f5;">'-summary'</span><span >,</span><span style="color: #a709f5;">'TDSE_SSO_6BM'</span><span >);</span></span></div></div></div><div  class = 'S8'><span>See </span><a href = "./QMol_test,html"><span style=' font-family: monospace;'>QMol_test</span></a><span> for details regarding how to create a test suite for new classes.</span></div><h2  class = 'S2' id = 'H_3BEADFD3' ><span>References</span></h2><div  class = 'S1' id = 'M_2A8D1A6C' ><span>[Blanes 2002] S. Blanes and P.C. Moan, "Practical symplectic partitioned Runge-Kutta and Runge-Kutta-Nystrom methods," Journal of Computational and Applied Mathematics 142, 313 (2002).</span></div><div  class = 'S1' id = 'M_F7CBFF54' ><span>[Mauger 2024] F. Mauger, C. Chandre, M.B. Gaarde, K. Lopata, and K.J. Schafer, "Hamiltonian formulation and symplectic split-operator schemes for time-dependent density-functional-theory equations of electron dynamics in molecules," Communications in Nonlinear Science and Numerical Simulation 129, 107685 (2024).</span></div><h2  class = 'S2' id = 'H_2E204287' ><span>Notes</span></h2><ul  class = 'S3'><li  class = 'S4'><span style=' font-family: monospace;'>QMol_TDSE_SSO_6BM</span><span> was introduced in version 01.20.</span></li></ul>
<br>
<!-- 
##### SOURCE BEGIN #####
%% |QMol_TDSE_SSO_6BM|
% Sixth-order optimized Blanes and Moan [Blanes 2002] symplectic split-operator 
% scheme for TDSE simulations.
%% Description
% Use |QMol_TDSE_SSO_6BM| to propagate the TDSE dynamics of a <./SE.html Schrödinger-equation 
% model> with a <./QMol_disc.html Cartesian-grid discretization domain> using 
% a sixth-order optimized Blanes and Moan [Blanes 2002] symplectic split-operator 
% scheme. The time propagation can be performed field free or with an external 
% driving field in the dipole approximation and either length or velocity gauge. 
% The derivation and details of the implementation of the symplectic split-operator 
% can be found in [Mauger 2024]. During the TDSE propagation, several observables 
% can be computed on-the-fly and stored in output structures in the |QMol_TDSE_SSO_6BM| 
% object. Each of these can be activated independently and may define their own 
% sampling times:
%% 
% * Save the Schrödinger-equation object into individual files
% * Save the dipole, dipole velocity, and dipole acceleration signals
% * Save Schrödinger-equation and wave function energies
% * Save the external field information
% * Save the ionization signal
% * Save the wave functions and their projection on a basis
% * Save the output of a function of the wave functions
% * Save restart data file
%% 
% See the <./TDSE.html TDSE documentation> page for examples of using most of 
% these features. 
% 
% |QMol_TDSE_SSO_6BM| is a handle class overloading |QMol_TDSE_SSO| (and thus 
% <./QMol_TDSE_sympSplitOp.html |QMol_TDSE_sympSplitOp|> and <./QMol_TDSE.html 
% |QMol_TDSE|>).
%% Class properties
% Time propagation
% |display (disp)|
% Whether to display progress of the TDSE calculation as it goes on |[ true 
% (default) | false ]|
% |time (T)|
% Time propagation vector |[ vector (default []) ]|
%% 
% * In all TDSE propagation simulations, |T(1)| specifies the starting time 
% and |T(end)| the ending time.
% * In forward time propagation simulations (|timeStep| |> 0|), time values 
% in |T| must be all increasing, while for backward time propagation (|timeStep| 
% |< 0|) they must be all decreasing. Time increments in the vector |T| need not 
% be equally spaced.
% * When |display| is activated, |T| specifies the intermediary times for the 
% time-propagation progress display.
% * |T| is also the default time sampling for saved results that do not define 
% their own.
% * Note that the time step used in TDSE propagations is set independently of 
% |T|.
% |timeStep (dt)|
% Time step used for the time propagation  |[ scalar (default 0.01) ]|
%% 
% * Positive (resp. negative) |timeStep| define forward (resp. backward) time 
% propagation.
% |splitMotif|
% Splitting motif |[ 'VTV' (default) | 'TVT' ]|
%% 
% * Whether the splitting starts with applying the potential (|'VTV'|) or kinetic 
% (|'TVT'|)  part of the Schrödinger-equation Hamiltonian.
% |absorbingBoundary (ABC)|
% Absorber at the edges of the domain |[ [] (default) | mask object | CAP object 
% ]|
%% 
% * The boundary absorber aims at eliminating outgoing wave packets from the 
% discretization domain and avoid spurious reflections at the edges of the domain.
% * Empty |absorbingBoundary| does not implement any absorbing boundary method 
% and any part of the wave packet reaching the edges of the domain will be reflected 
% (or articifially reappears on the other side of the domain through periodic 
% effects).
% * Mask absorbers are applied at the end of each propagation step. They are 
% the easiest to use and implement but are first order, irrespective of the order 
% of the time propagation scheme. 
% * Complex absorbing potentials (CAPs) are integrated within the propagation 
% scheme, as an imaginary potential term that causes exponential decay of the 
% wave packet at the edges. Under the right circumstances, CAPs can preserve the 
% order of the propagation schemes. 
% |externalField (EF)|
% External driving field |[ [] (default) || <./QMol_extField_dipole.html |QMol_extField_dipole|> 
% |object ]|
%% 
% * When performing the TDSE propagation, any |electricField|, |electricFieldDerivative|, 
% or |potentialVector| are repackaged into |externalField|.
% * If no electric field or potential vector is defined, either through |externalField,| 
% |electricField|, or |potentialVector|, the TDSE propagation is performed field 
% free.
% |externalFieldGauge (EFG)|
% Gauge in which the external driving field is described |[ [] (default) | 'none' 
% | 'length' | 'velocity' ]|
%% 
% * |'none'| ignores any input external field and propagates the field-free 
% TDSE dynamics.
% * The decision tree for the selection of the default gauge is detailed below.
% |electricField (FE)|
% Electric field of the external driving field |[ [] (default) | function handle 
% | griddedInterpolant ]|
%% 
% * For developers: When initializing the class, non-empty |electricField| is 
% moved into the |externalField| property object (if needed creating the object 
% first). During run time, |FE| contains the value of the electric field used 
% in the propagation (where relevant).
% |electricFieldDerivative (FDE)|
% Derivative of the electric field of the external driving field |[ [] (default) 
% | function handle | griddedInterpolant ]|
%% 
% * |griddedInterpolant| |electricFieldDerivative| is provided for general support 
% but note that non-function-handle electric field derivatives are computed self-consistently 
% from the electric-field or potential-vector components.
% * For developers: When initializing the class, non-empty |electricFieldDerivative| 
% is moved into the |externalField| property object (if needed creating the object 
% first). During run time, |FDE| contains the value of the derivative of the electric 
% field used in the propagation (where relevant).
% |potentialVector (FA)|
% Potential vector of the external driving field |[ [] (default) | function 
% handle | griddedInterpolant ]|
%% 
% * For developers: When initializing the class, non-empty |potentialVector| 
% is moved into the |externalField| property object (if needed creating the object 
% first). During run time, |FA| contains the value of the potential vector used 
% in the propagation (where relevant).
% |diffDT|
% Time step for used for computing time derivatives |[ nonnegative scalar (default 
% 1e-5) ]|
% Save the Schrödinger-equation object into individual files
% During the time propagation, copies of the Schrödinger-equation object can 
% be saved in separate MATLAB files.
% |saveSE (sSE)|
% Activate saving the Schrödinger-equation object into separate files |[ true 
% | false (default) ]|
% |saveSEFileName (sSEF)|
% Name for the files in which the Schrödinger-equation objects are saved |[ 
% character array (default 'QMolGridREPLACE_WITH_DASH_DASHTDSEREPLACE_WITH_DASH_DASHSE') ]|
%% 
% * The Schrödinger-equation objects saved at different times are put in separate 
% MATLAB (.mat.) file, with names starting with |saveSEFileName| to which the 
% iteration index is appended. Each file produced also contains a scalar variable 
% |t| with the time information.
% * One may specify a location where to create the files by indicating the folder 
% path in |saveSEFileName|.
% * |saveSEFileName| is irrelevant when |saveSE| |== false|.
% |saveSETime (sSET)|
% Times at which to save the Schrödinger-equation object into a file |[ [] (default) 
% | positive scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveSETime| uses the same values as in |time| for when to save the 
% Schrödinger-equation object into MATLAB files.
% * A positive scalar specifies the sampling time step when to save the Schrödinger-equation 
% object into MATLAB files. For forward time propagation, it is equivalent to 
% time|(1):saveSETime:|time|(end)|, and for backward ones to time|(1):-saveSETime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% saves. For forward time propagation, it is equivalent to time|(1):abs(saveSETime)*||timeStep||:|time|(end)|, 
% and for backward one to time|(1):-abs(saveSETime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to save the Schrödinger-equation 
% object to a MATLAB file.
% * |'all'| saves the Schrödinger-equation object into a MATLAB file after every 
% time step. Warning: this is slow and may result in a very large number of file 
% and/or large disk usage.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Save the dipole, dipole velocity, and dipole acceleration signals
% |saveDipole (sDip)|
% Whether to calculate and save the dipole signal during the TDSE propagation 
% |[ true | false (default) ]|
% |saveDipoleWaveFunctionIndex (sDipI)|
% Index of the wave functions for which to compute the dipole signal |[ [] (default) 
% | index vector | 'all' ]|
%% 
% * This is irrelevant if |saveDipole| is |false|.
% * Specify the indexes of the wave functions for which to compute the orbital-resolved 
% dipole signal in an index vector.
% * Empty or |'all'| |saveDipoleWaveFunctionIndex| computes the orbital-resolved 
% dipole for all wave functions.
% |saveDipoleTime (sDipT)|
% Times at which to compute and save the dipole signal |[ [] (default) | positive 
% scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveDipoleTime| uses the same values as in |time| for when to compute 
% and save the dipole signal.
% * A positive scalar specifies the sampling time step between successive computations 
% of the dipole signal. For forward time propagation, it is equivalent to time|(1):saveDipoleTime:|time|(end)|, 
% and for backward one to time|(1):-saveDipoleTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% dipole-signal computations. For forward time propagation, it is equivalent to 
% time|(1):abs(saveDipoleTime)*||timeStep||:|time|(end)|, and for backward one 
% to time|(1):-abs(saveDipoleTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to compute and save the dipole 
% signal.
% * |'all'| computes and saves the dipole signal after every time step. Warning: 
% this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% |saveDipoleVelocity (sVel)|
% Whether to calculate and save the dipole velocity signal during the TDSE propagation 
% |[ true | false (default) ]|
% |saveDipoleVelocityWaveFunctionIndex (sVelI)|
% Index of the wave functions for which to compute the orbital-resolved dipole 
% velocity signal |[ [] (default) | index vector | 'all' ]|
%% 
% * This is irrelevant if |saveDipoleVelocity| is |false|.
% * Specify the indexes of the wave functions for which to compute the dipole 
% velocity signal in an index vector.
% * Empty or |'all'| |saveDipoleVelocityWaveFunctionIndex| computes the dipole 
% velocity for all wave functions.
% |saveDipoleVelocityTime (sVelT)|
% Times at which to compute and save the dipole velocity signal |[ 'dipole' 
% (default) | positive scalar | negative integer | vector | 'all' ]|
%% 
% * |'dipole'| |saveDipoleVelocityTime| uses the same times as for |saveDipoleTime|.
% * A positive scalar specifies the sampling time step between successive computations 
% of the dipole velocity signal. For forward time propagation, it is equivalent 
% to time|(1):saveDipoleVelocityTime:|time|(end)|, and for backward one to time|(1):-saveDipoleVelocityTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% dipole-velocity-signal computations. For forward time propagation, it is equivalent 
% to time|(1):abs(saveDipoleVelocityTime)*||timeStep||:|time|(end)|, and for backward 
% one to time|(1):-abs(saveDipoleVelocityTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to compute and save the dipole 
% velocity signal.
% * |'all'| computes and saves the dipole velocity signal after every time step. 
% Warning: this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% |saveDipoleAcceleration (sAcc)|
% Whether to calculate and save the dipole acceleration signal during the TDSE 
% propagation |[ true | false (default) ]|
% |saveDipoleAccelerationWaveFunctionIndex (sAccI)|
% Index of the wave functions for which to compute the dipole acceleration signal 
% |[ [] (default) | index vector | 'all' ]|
%% 
% * This is irrelevant if |saveDipoleAcceleration| is |false|.
% * Specify the indexes of the wave functions for which to compute the dipole 
% acceleration signal in an index vector.
% * Empty or |'all'| |saveDipoleAccelerationWaveFunctionIndex| computes the 
% dipole acceleration for all wave functions.
% |saveDipoleAccelerationTime (sAccT)|
% Times at which to compute and save the dipole acceleration signal |[ 'dipole' 
% (default) | positive scalar | negative integer | vector | 'all' ]|
%% 
% * |'dipole'| |saveDipoleAccelerationTime| uses the same times as for |saveDipoleTime|.
% * A positive scalar specifies the sampling time step between successive computations 
% of the dipole acceleration signal. For forward time propagation, it is equivalent 
% to time|(1):saveDipoleAccelerationTime:|time|(end)|, and for backward one to 
% time|(1):-saveDipoleAccelerationTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% dipole-acceleration-signal computations. For forward time propagation, it is 
% equivalent to time|(1):abs(saveDipoleAccelerationTime)*||timeStep||:|time|(end)|, 
% and for backward one to time|(1):-abs(saveDipoleAccelerationTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to compute and save the dipole 
% acceleration signal.
% * |'all'| computes and saves the dipole acceleration signal after every time 
% step. Warning: this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Save Schrödinger-equation and wave function energies
% |saveEnergySE (sESE)|
% Whether to track the Schrödinger-equation energy during the TDSE propagation 
% |[ true | false (default) ]|
% |saveEnergySETime (sESET)|
% Times at which to compute and save the Schrödinger-equation energy |[ [] (default) 
% | positive scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveEnergySETime| uses the same values as in |time| for when to compute 
% and save the Schrödinger-equation energy
% * A positive scalar specifies the sampling time step between successive computations 
% of the Schrödinger-equation energy. For forward time propagation, it is equivalent 
% to time|(1):saveEnergySETime:|time|(end)|, and for backward one to time|(1):-saveEnergySETime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% Schrödinger-equation-energy computations. For forward time propagation, it is 
% equivalent to time|(1):abs(saveEnergySETime)*||timeStep||:|time|(end)|, and 
% for backward one to time|(1):-abs(saveEnergySETime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to compute and save the Schrödinger-equation 
% energy.
% * |'all'| computes and saves the Schrödinger-equation energy after every time 
% step. Warning: this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% |saveEnergyWaveFunction (sEWfcn)|
% Whether to track the wave function energies during the TDSE propagation |[ 
% true | false (default) ]|
%% 
% * For a wave function $|\psi\rangle$, the orbital energy is defined as $\langle\psi|\hat{\mathcal{H}}|\psi\rangle$ 
% with $\hat{\mathcal{H}}$ the Schrödinger-equation Hamiltonian operator.
% * In the velocity gauge, the external potential vector is accounted for in 
% the kinetic-operator of $\hat{\mathcal{H}}$ while, in the length gauge, the 
% external electric field is ignored.
% * Note that the energy of all the wave functions are computed and saved. One 
% may use an installable output function to track the energy of a subset of wave 
% functions.
% |saveEnergyWaveFunctionTime (sEWfcnT)|
% Times at which to compute and save the wave function energies |[ [] (default) 
% | positive scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveEnergyWaveFunctionTime| uses the same values as in |time| for 
% when to compute and save the wave fuction energies
% * A positive scalar specifies the sampling time step between successive computations 
% of the wave function energies. For forward time propagation, it is equivalent 
% to time|(1):saveEnergyWaveFunctionTime:|time|(end)|, and for backward one to 
% time|(1):-saveEnergyWaveFunctionTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% wave-function-energy computations. For forward time propagation, it is equivalent 
% to time|(1):abs(saveEnergyWaveFunctionTime)*||timeStep||:|time|(end)|, and for 
% backward one to time|(1):-abs(saveEnergyWaveFunctionTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to compute and save the wave 
% function energies.
% * |'all'| computes and saves the wave function energies after every time step. 
% Warning: this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Save the external field information
% |saveExternalField (sEF)|
% For TDSE simulation with and external driving field, save the external field 
% in the output structures |[ true | false (default) ]|
%% 
% * When activated (|saveExternalField = true|), the information about the external 
% driving field at the sampled times is added to each of the output structures.
% * For practical reasons, the values for the external driving field may be 
% slightly different from that of |externalField|. This features enables keeping 
% the actual external-field values used throughout the propagation.
% Save the ionization signal
% The ionization signal tracks how much density leaves the simulation domain 
% by being absorbed at the boundaries.
% |saveIonization (sIon)|
% Whether to calculate and save the ionization signal during the TDSE propagation 
% |[ true | false (default) ]|
% |saveIonizationWaveFunctionIndex (sIKSOI)|
% Index of the wave functions for which to compute the orbital-resolved ionization 
% signal |[ [] (default) | index vector | 'all' ]|
%% 
% * This is irrelevant if |saveIonization| is |false|.
% * Specify the indexes of the wave functions for which to compute the ionization 
% signal in an index vector.
% * Empty or |'all'| |saveIonizationWaveFunctionIndex| computes the ionization 
% for all wave functions.
% |saveIonizationTime (sIonT)|
% Times at which to compute and save the ionization signal |[ [] (default) | 
% positive scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveIonizationTime| uses the same values as in |time| for when to 
% compute and save the ionization signal.
% * A positive scalar specifies the sampling time step between successive computations 
% of the ionization signal. For forward time propagation, it is equivalent to 
% time|(1):saveIonizationTime:|time|(end)|, and for backward one to time|(1):-saveIonizationTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% ionization-signal computations. For forward time propagation, it is equivalent 
% to time|(1):abs(saveIonizationTime)*||timeStep||:|time|(end)|, and for backward 
% one to time|(1):-abs(saveIonizationTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to compute and save the ionization 
% signal.
% * |'all'| computes and saves the ionization signal after every time step. 
% Warning: this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Save the wave functions and their projection on a basis
% Warning: The memory requirements for saving the wave functions throughout 
% the TDSE propagation may grow very fast and trigger an error (if MATLAB runs 
% out of memory). Instead, if the full wave function is required consider saving 
% the Schrödinger-equation object in separate files, or if only the result of 
% a specify calculation on the wave functions is required consider consider using 
% an installable output function.
% |saveWaveFunction (sWfcn)|
% Whether to save the wave functions during the TDSE propagation |[ true | false 
% (default) ]|
% |saveWaveFunctionIndex (sWfcnI)|
% Index of the wave functions to save |[ [] (default) | index vector | 'all' 
% ]|
%% 
% * This is irrelevant if |saveWaveFunction| is |false|.
% * Empty |saveWaveFunctionIndex| disables saving of the wave functions and 
% is technically equivalent to |saveWaveFunction||= false|.
% * Specify the indexes of the wave functions to save in an index vector.
% * |'all'| saves all the wave functions.
% |saveWaveFunctionTime (sWfcnT)|
% Times at which to save the wave functions |[ [] (default) | positive scalar 
% | negative integer | vector | 'all' ]|
%% 
% * Empty |saveWaveFunctionTime| uses the same values as in |time| for when 
% to save the wave functions.
% * A positive scalar specifies the sampling time step between successive saving 
% of the wave functions. For forward time propagation, it is equivalent to time|(1):saveWaveFunctionTime:|time|(end)|, 
% and for backward one to time|(1):-saveWaveFunctionTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% saving wave functions. For forward time propagation, it is equivalent to time|(1):abs(saveWaveFunctionTime)*||timeStep||:|time|(end)|, 
% and for backward one to time|(1):-abs(saveWaveFunctionTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to save the wave functions.
% * |'all'| saves the wave functions after every time step. Warning: generally 
% discouraged as it likely results in very large memory requirements or cause 
% an out-of-memory error REPLACE_WITH_DASH_DASH see the warning above.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% |saveWaveFunctionProjection (sWfcnP)|
% Whether to save the projection of the wave functions onto a specific basis 
% during the TDSE propagation |[ true | false (default) ]|
% |saveWaveFunctionProjectionBasis (sWfcnB)|
% Projection basis |[ [] (default) | matrix basis || <./QMol_disc_basis.html 
% |QMol_disc_basis|> |]|
%% 
% * Empty |saveWaveFunctionProjectionBasis| uses the initial wave functions 
% as the projection basis.
% * matrix |saveWaveFunctionProjectionBasis| specifies the projection basis 
% to be used, with the projection vectors specified in each column of the matrix. 
% * <./QMol_disc_basis.html |QMol_disc_basis|> |saveWaveFunctionProjectionBasis| 
% uses the basis set of the associated domain definition. 
% * For both matrix and <./QMol_disc_basis.html |QMol_disc_basis|>, the user-defined 
% basis set is assumed to be a proper orthonormal family defined over the same 
% domain grid as the Schrödinger-equation model being propagated. The TDSE propagator 
% does not check for this and will produce erroneous results, or trigger an error, 
% otherwise.
% |saveWaveFunctionProjectionIndex (sWfcnPI)|
% Index of the wave functions for which to perform the projection |[ [] (default) 
% | index vector | 'all' ]|
%% 
% * This is irrelevant if |saveWaveFunctionProjection| is |false|.
% * Empty |saveWaveFunctionProjectionIndex| disables saving of the wave functions 
% and is technically equivalent to |saveWaveFunctionProjection| |= false|.
% * Specify the indexes of the wave functions for which to perform the projection 
% in an index vector.
% * |'all'| saves the projection for all the wave functions.
% |saveWaveFunctionProjectionTime (sWfcnPT)|
% Times at which to save the projection of the wave functions |[ [] (default) 
% | positive scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveWaveFunctionProjectionTime| uses the same values as in |time| 
% for when to save the projection of the wave functions.
% * A positive scalar specifies the sampling time step between successive saving 
% of the wave functions' projection. For forward time propagation, it is equivalent 
% to time|(1):saveWaveFunctionProjectionTime:|time|(end)|, and for backward one 
% to time|(1):-saveWaveFunctionProjectionTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% saving wave functions' projection. For forward time propagation, it is equivalent 
% to time|(1):abs(saveWaveFunctionProjectionTime)*||timeStep||:|time|(end)|, and 
% for backward one to time|(1):-abs(saveWaveFunctionProjectionTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to save the wave functions' 
% projection.
% * |'all'| saves the wave functions' projection after every time step. Warning: 
% this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Save the output of a functions of the wave function
% This enables on-the-fly computation and saving of user-defined observables 
% without having to save the Schrödinger-equation object or the wave functions.
% |saveOutputFunction (sF)|
% Installable output function of the wave functions |[ [] (default) | function 
% handle ]|
%% 
% * Leave empty to disable the feature.
% * Provide a function handle to enable the feature. The signature for the function 
% is |fun(wfcn,t)|, where |wfcn| is a wave function object and |t| is the time 
% (scalar). The function handle may return an array of arbitrary size and shape, 
% but must return at least a scalar and the shape of the output must remain constant 
% throughout the TDSE propagation.
% * Warning: The Schrödinger-equation model wave functions are passed by reference 
% to the output function. Thus modifying the wave functions in the output function 
% will also modify them for the Schrödinger-equation model (and thus TDSE propagation) 
% and will likely result in erroneous results or produce an error.
% |saveOutputFunctionTime (sFT)|
% Times at which to evaluate and save the installable output function of the 
% wave functions |[ [] (default) | positive scalar | negative integer | vector 
% | 'all' ]|
%% 
% * Empty |saveOutputFunctionTime| uses the same values as in |time| for when 
% to evaluate and save the output function.
% * A positive scalar specifies the sampling time step between successive evaluation 
% and saving of the output function. For forward time propagation, it is equivalent 
% to time|(1):saveOutputFunctionTime:|time|(end)|, and for backward one to time|(1):-saveOutputFunctionTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% evaluations and saving of the output function. For forward time propagation, 
% it is equivalent to time|(1):abs(saveOutputFunctionTime)*||timeStep||:|time|(end)|, 
% and for backward one to time|(1):-abs(saveOutputFunctionTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to evaluate and save the output 
% function.
% * |'all'| evaluates and saves the output function after every time step. Warning: 
% this may be slow.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Save restart data file
% During the time propagation, a restart file can be generated to enable resuming 
% the simulation if it is cut short. Stopping the TDSE simulation while it writes 
% the restart info may lead to a corrupted file from which restart will not be 
% possible. The restart file contains a copy of the TDSE-propagator and Schrödinger-equation-model 
% objects, respectively called |TDSE| and |SE|.
% |saveRestart (sRest)|
% Activate the generation of a restart file |[ true | false (default) ]|
% |saveRestartFileName (sRestF)|
% Name for the restart file |[ chracter array (default 'QMolGridREPLACE_WITH_DASH_DASHTDSEREPLACE_WITH_DASH_DASHRestart.mat') 
% ]|
%% 
% * |saveRestartFileName| must be a valid MATLAB file name ('.mat' extension).
% * |saveRestartFileName| is irrelevant when |saveRestart| |== false|.
% |saveRestartTime (sRestT)|
% Times at which to generate or update the restart file |[ [] (default) | positive 
% scalar | negative integer | vector | 'all' ]|
%% 
% * Empty |saveRestartTime| uses the same values as in |time| for when to generate 
% and update the restart file.
% * A positive scalar specifies the sampling time step when to generate and 
% update the restart file. For forward time propagation, it is equivalent to time|(1):saveRestartTime:|time|(end)|, 
% and for backward one to time|(1):-saveRestartTime:|time|(end)|.
% * A negative integer specifies the number of propagation time steps between 
% the generation and update of the restart file. For forward time propagation, 
% it is equivalent to time|(1):abs(saveRestartTime)*||timeStep||:|time|(end)|, 
% and for backward one to time|(1):-abs(saveRestartTime)*||timeStep||:|time|(end)|.
% * A vector provides user-defined times at which to generate and update the 
% restart file.
% * |'all'| generates and updates the restart file after each time step. Warning: 
% this is very slow and is strongly discouraged.
% * Note: In all cases, no restart file is generated for the initial time and 
% final propagation time step.
% * See the note on how intermediate time saving is performed during the TDSE 
% propagation below.
% Output results
% During a TDSE propagation, the results of on-the-fly calculations are strored 
% in structures in the |QMol_TDSE| object. Note that |QMol_TDSE| does not interpolate 
% its time propagation to fit user-supplied sample times, Insatead, the results 
% are saved at the closest propagation time steps, excluding duplicate times. 
% This may result in sampled times that are different, or have a different (smaller) 
% number of elements, from the ones specified above. Notably, using a sampling 
% time that is not a multiple of the propagation time step may result in uneven 
% saved time sampling. The actual times at with output are saved is included in 
% each of the output structure.
% 
% When |saveExternalField| is |true|, each output-result structure includes 
% the following fields:
%% 
% * In the length gauge, |outStructure.electricField| contains the specific 
% values for the electric field used in the TDSE propagation at the saved times.
% * In the velocity gauge, |outStructure.potentialVector| contains the specific 
% values for the potential vector used in the TDSE propagation at the saved times.
% * In all cases, if the potential vector, electric field, or derivative of 
% the electric field are calculated by the propagator during the simulations (see 
% the decision tree below), those are included in |outStructure.potentialVector|, 
% |outStructure.electricField|, and |outStructure.electricFieldDerivative|, respectively
%% 
% In restart mode, each of the output structure contains a handful of additional 
% fields to the ones listed below that are relevant for run-time calculations. 
% These fields are saved in the MATALB restart file but removed upon completion 
% of the TDSE propagation.
% |outDipole (oDip)|
% Result of dipole-signal calculations during the TDSE propagation |[ [] | structure 
% ]|
%% 
% * TDSE propagation that does not compute the dipole signal (|saveDipole| |= 
% false|) leaves |outDipole| empty. Otherwise:
% * |outDipole.time| defines the precise times at which the dipole signal is 
% computed.
% * |outDipole.waveFunction_x| contains the dipole signal for selected wave 
% functions. The indices of the wave functions associated with each of these are 
% included in |outDipole.indexWaveFunction|.
% |outDipoleVelocity (oVel)|
% Result of dipole-velocity-signal calculations during the TDSE propagation 
% |[ [] | structure ]|
%% 
% * TDSE propagation that does not compute the dipole signal (|saveDipoleVelocity| 
% |= false|) leaves |outDipoleVelocity| empty. Otherwise:
% * |outDipoleVelocity.time| defines the precise times at which the dipole velocity 
% signal is computed.
% * |outDipoleVelocity.waveFunction_x| contains the dipole signal for selected 
% wave functions. The indices of the wave functions associated with each of these 
% are included in |outDipoleVelocity.indexWaveFunction|.
% |outDipoleAcceleration (oAcc)|
% Result of dipole-acceleration-signal calculations during the TDSE propagation 
% |[ [] | structure ]|
%% 
% * TDSE propagation that does not compute the dipole signal (|saveDipoleAcceleration| 
% |= false|) leaves |outDipoleAcceleration| empty. Otherwise:
% * |outDipoleAcceleration.time| defines the precise times at which the dipole 
% acceleration signal is computed.
% * |outDipoleVelocity.waveFunction_x| contains the dipole signal for selected 
% wave functions. The indices of the wave functions associated with each of these 
% are included in |outDipoleAcceleration.indexWaveFunction|.
% |outEnergySE (oESE)|
% Result of the Schrödinger-equation-energy calculations during the TDSE propagation 
% |[ [] | structure ]|
%% 
% * TDSE propagation that does track the Schrödinger-equation energy (|saveEnergySE| 
% |= false|) leaves |outEnergySE| empty. Otherwise:
% * |outEnergySE.time| defines the precise times at which the Schrödinger-equation 
% energies are computed.
% * |outEnergySE.total| contains the total Schrödinger-equation energy, which 
% should be constant (within the precision of the propagation scheme).
% * |outEnergySE.kinetic| contains the kinetic-energy component, including the 
% driving-field potential vector in the velocity gauge. 
% * |outEnergySE.potential| contains the potential-energy component. 
% * |outEnergySE.externalField| contains the energy contribution from the driving 
% electric field in the length gauge.
% * |outEnergySE.autonomization| contains the energy brought in and out of the 
% system by the external driving field (if any).
% |outEnergyWaveFunction (oEWfcn)|
% Result of the wave-function-energy calculations during the TDSE propagation 
% |[ [] | structure ]|
%% 
% * TDSE propagation that does track the Schrödinger-equation energy (|saveEnergyWaveFunction| 
% |= false|) leaves |outEnergyWaveFunction| empty. Otherwise:
% * For a wave function $|\psi\rangle$, the energy is defined as $\langle\psi|\hat{\mathcal{H}}|\psi\rangle$ 
% with $\hat{\mathcal{H}}$ the Schrödinger-equation Hamiltonian operator. In the 
% velocity gauge, the external potential vector is accounted for in the kinetic-operator 
% of $\hat{\mathcal{H}}$ while, in the length gauge, the external electric field 
% is ignored.
% * |outEnergyWaveFunction.time| defines the precise times at which the wave 
% function energies are computed.
% * Each row of |outEnergyWaveFunction.waveFunction| contains the energies of 
% the corresponding wave functions.
% |outIonization (oIon)|
% Result of the ionization calculations during the TDSE propagation |[ [] | 
% structure ]|
%% 
% * TDSE propagation that does track ionization (|saveIonization| |= false|) 
% leaves |outIonization| empty. Otherwise:
% * |outIonization.time| defines the precise times at which the ionization is 
% computed.
% * |outIonization.waveFunction| contains the ionization for the selected wave 
% functions. The indices of the wave functions associated with each of these are 
% included in |outIonization.indexWaveFunction|.
% |outWaveFunction (oWfcn)|
% Wave functions during the TDSE propagation |[ [] | structure ]|
%% 
% * TDSE propagation that does not save the wave function (|saveWaveFunction| 
% |= false|) leaves |outWaveFunction| empty. Otherwise:
% * The specific shape of the saved wave functions is implementation dependent 
% REPLACE_WITH_DASH_DASH see the corresponding documentation for details. At minimum, each implementation 
% defines:
% * |outWaveFunction.time| defines the precise times at which the wave functions 
% are saved.
% * |outWaveFunction.waveFunction| contains the saved wave functions and |outWaveFunction.indexWaveFunction| 
% the corresponding wave-function indices.
% |outWaveFunctionProjection (oWfcnP)|
% Projection of the wave functions during the TDSE propagation |[ [] | structure 
% ]|
%% 
% * TDSE propagation that does not save the projection of the wave functions 
% (|saveWaveFunctionProjection| |= false|) leaves |outWaveFunctionProjection| 
% empty. Otherwise:
% * The specific shape of the saved wave functions' projection is implementation 
% dependent REPLACE_WITH_DASH_DASH see the corresponding documentation for details. At minimum, each 
% implementation defines:
% * |outWaveFunctionProjection.time| defines the precise times at which the 
% wave function projections are saved.
% * |outWaveFunctionProjection.waveFunction| contains the saved wave functions' 
% projection and |outWaveFunctionProjection.indexWaveFunction| the corresponding 
% wave function indices.
% * The structure also retains a copy of the projection basis as <./QMol_disc_basis.html 
% |QMol_disc_basis|> object(s).
% |outOutputFunction (oF)|
% Result of the installable output function of the wave functions |[ [] | structure 
% ]|
%% 
% * TDSE propagation that does not define an installabe output function (|saveOutputFunction| 
% |= []|) leaves |outOutputFunction| empty. Otherwise:
% * |outOutputFunction.time| defines the precise times at which the result of 
% the output function is saved.
% * |outOutputFunction.result| contains the results of the output function. 
% If the installable function returns a scalar or a column vector, |outOutputFunction.result| 
% is a |N-by-numel(outOutputFunction.time)| matrix with |N| the numer of elements 
% in the output. Otherwise, |outOutputFunction.result| is an |M-by-numel(outOutputFunction.time)| 
% array with |M| the size of the output.
% * |outOutputFunction.shape| contains the shape of the output function (|N| 
% or |M|, as defined in the previous bullet point).
%% Class methods
% Creation
% constructor
% Create a sixth-order optimized Blanes and Moan [Blanes 2002] symplectic TDSE-propagator 
% object with empty class properties.

obj = QMol_TDSE_SSO_6BM;
%% 
% Create a TDSE-propagator object with the |name| properties set to the specified 
% |value|. Several |name-value| pairs can be specified consecutively. Suitable 
% |name| is any of the TDSE class properties and is case insensitive.

obj = QMol_TDSE_SSO_6BM(name1,value1);
obj = QMol_TDSE_SSO_6BM(name1,value1,name2,value2,___);
% Changing class properties
% |set|
% Update the |name| properties of a TDSE-model object to the specified |value|. 
% Several |name-value| pairs can be specified consecutively. Suitable |name| is 
% any of the TDSE class properties and is case insensitive. In restart mode, output 
% result structures can also be edited with |set|. |QMol_TDSE| does not check 
% the integrity of its input/output component during a restart and this feature 
% should only be considered by advanced users.

obj.set(name1,value1);
obj.set(name1,value1,name2,value2,___);
%% 
% This is the common name-value pair assignment method used throughout the QMol-grid 
% package.
% |clear|
% Clear all class properties.

obj.clear;
%% 
% Clear a specific set of the class properties. Suitable |name| is any of the 
% TDSE class properties and is case insensitive.

obj.clear(name1,name2,___);
%% 
% This is the common |clear| method available to all classes throughout the 
% QMol-grid package. The |clear| method can be used to delete specific properties 
% before saving an instance of the TDSE propagators class and propagation results.
% Initializing the object
% |initialize|
% Initialize a sixth-order optimized Blanes and Moan [Blanes 2002] symplectic 
% TDSE-propagator object without allocating the output-result structures.

obj.initialize(SE);
%% 
% * |SE| is the <./SE.html Schrödinger-equation-model> handle object, _i.e._, 
% <./QMol_SE.html |QMol_SE|>, that describes the Schrödinger-equation systems 
% to propagate.
% * For developers: |initialize| also has a specific interface when called from 
% the |propagate| method that initializes the absorbing boundaries (if any) and 
% determines whether the output-result structures should be initialized too. Overloading 
% classes should avoid redefining |initialize|; If the overloading class needs 
% to perform some initialization (at the beginning of a TDSE propagation or upon 
% restart), overload the |initializeChildren| method instead.
% Run-time documentation
% |getMemoryProfile|
% Get an estimate of the memory help by a |QMol_TDSE_SSO_6BM| object with either

mem = obj.getMemoryProfile;
mem = obj.getMemoryProfile(false);
%% 
% * The object must be |initialize|d for the memory footprint evaluation. If 
% not arleady, |getMemoryProfile| initializes the Schrödinger-equation model object.
% * The estimate includes the (1) Schrödinger-equation model, (2) TDSE propagator, 
% and (3) output results. Note that all these components may not be used in actual 
% simulations and the memory estimate tries to be conservative. On the other hand, 
% it only includes the discretization of member components on the domain grid 
% and ignores other (expectedly small) properties.
% * The output |mem| is the estimated size in bytes.
%% 
% Additionally display the detail of the memory footprint with

mem = obj.getMemoryProfile(true);
% |showDocumentation|
% Display the run-time documentation for the specific configuration of a |QMol_TDSE_SSO_6BM| 
% object, wich must have been |initialize|d beforehand

obj.showDocumentation;
% TDSE propagation
% |propagate|
% Propagate the TDSE dynamics starting from a Schrödinger-equation model object 
% (from scratch).

obj.propagate(SE);
%% 
% * |SE| is the <./SE.html Schrödinger-equation-model> handle object, _i.e._, 
% <./QMol_SE.html |QMol_SE|>, that describes the Schrödinger-equation systems 
% to propagate.
% * Neither the TDSE-propagation |obj| nor the Schrödinger-equation-model |SE| 
% objects need be |initialize|d. In all cases both are (re)initialized at the 
% beginning of the TDSE propagation to ensure proper and consistent linkage and 
% setup between them.
%% 
% Restart a TDSE propagation.

obj.propagate('restart');
%% 
% * This can be performed after loading the corresponding restart MATLAB file 
% into the workspace.
% Choice of gauge
% If no specific gauge is specified with |externalFieldGauge|, the gauge is 
% selected following the decision tree:
%% 
% * Length gauge if |externalField||.electricField| or |electricField| is a 
% function handle, otherwise:
% * Velocity gauge if |externalField||.potentialVector| or |potentialVector| 
% is a function handle, otherwise:
% * Length gauge if |externalField||.electricField| or |electricField| is a 
% |griddedInterpolant|, otherwise:
% * Velocity gauge if |externalField||.potentialVector| or |potentialVector| 
% is a |griddedInterpolant|, otherwise:
% * Field free (ignore any input field).
% External-field components used in simulations
% Depending on the types of input, not all provided external-field may be used 
% in the simulations. For the potential vector and electric field REPLACE_WITH_DASH_DASH recall that 
% |electricField| and |potentialVector| are repackaged into |externalField| at 
% the beginning of the simulation: 
%% 
% * If both are provided as function handles, then |externalField||.electricField| 
% and |externalField||.potentialVector| are called whenever the values for the 
% potential vector or electric field are required. Note that the TDSE propagator 
% does not check whether the provided potential vector and electric field are 
% consistent with each other ($E(t)=-\partial_t A(t)$) and providing non-matching 
% components will likely result in erroneous results. Otherwise,
% * If only one of them is provided as a function handle, then both the potential 
% vector and electric field are computed from that same function handle (see below 
% for details on how this is done). Otherwise,
% * In the length gauge, if |externalField||.electricField| is a |griddedInterpolant| 
% then it is used to compute both the electric field and potential vector, otherwise, 
% |externalField||.potentialVector| is used to compute them both.
% * In the velocity gauge, if |externalField||.potentialVector| is a |griddedInterpolant| 
% then it is used to compute both the electric field and potential vector, otherwise, 
% |externalField||.electricField| is used to compute them both.
% * If none of the |externalField||.electricField| and |externalField||.potentialVector| 
% are defined, the TDSE propagation is performed field free irrespective of the 
% choice of |externalFieldGauge| and even if an |externalField||.electricFieldDerivative| 
% is defined.
%% 
% The choice of ignoring some (interpolated) input fields is made to ensure 
% the self-consistency of the TDSE dynamics, and associated observables, during 
% the numerical propagation. To force using an interpolated field input, one can 
% encapsulate it into a function handle |@(t) interpolatedField(t)|. 
% 
% For the electric-field derivative:
%% 
% * If |externalField||.electricFieldDerivative| is defined as a function handle, 
% then |externalField||.electricFieldDerivative| is called when the derivative 
% of the electric field is required.
% * Otherwise the electric-field derivative is numerically computed from |externalField||.electricField| 
% or |externalField||.potentialVector|, depending on which field component(s) 
% are being used in the TDSE propagation. 
%% 
% Numerical computation of missing or ignored field components:
%% 
% * Where required, the potential vector is computed from the electric field 
% using a Simpson's 1/3 quadrature rule.
% * Where required, the electric field is computed from the potential vector 
% using a second-order centered finite difference with |diffDT| time step.
% * Where required, the electric field derivative is computed from the electric 
% field or the potential vector using a second-order centered finite difference 
% with |diffDT| time step.
%% Examples
% See the <./TDDFT.html main documentation page> for examples of TDSE simulations 
% with various output computations.
%% Test suite
% For consistency with the rest of the QMol-grid package, |QMol_TDSE_SSO_6BM| 
% defines an associated test suite. Run the test suite for the class in normal 
% or <./Test_suite.html summary mode> respectively with

QMol_test.test('TDSE_SSO_6BM');
QMol_test.test('-summary','TDSE_SSO_6BM');
%% 
% See <./QMol_test,html |QMol_test|> for details regarding how to create a test 
% suite for new classes.
%% References
% [Blanes 2002] S. Blanes and P.C. Moan, "Practical symplectic partitioned Runge-Kutta 
% and Runge-Kutta-Nystrom methods," Journal of Computational and Applied Mathematics 
% 142, 313 (2002).
% 
% [Mauger 2024] F. Mauger, C. Chandre, M.B. Gaarde, K. Lopata, and K.J. Schafer, 
% "Hamiltonian formulation and symplectic split-operator schemes for time-dependent 
% density-functional-theory equations of electron dynamics in molecules," Communications 
% in Nonlinear Science and Numerical Simulation 129, 107685 (2024).
%% Notes
%% 
% * |QMol_TDSE_SSO_6BM| was introduced in version 01.20.
##### SOURCE END #####
-->
</div></body></html>